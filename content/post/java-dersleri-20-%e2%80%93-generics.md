title: Java Dersleri 24 – Generics
link: http://orhanbalci.net/tr/?p=1304
author: Orhan Balci
description: 
post_id: 1304
created: 2014/11/19 13:31:33
created_gmt: 2014/11/19 10:31:33
comment_status: open
post_name: java-dersleri-20-%e2%80%93-generics
status: publish
post_type: post

# Java Dersleri 24 – Generics

Javada generics yapısı tiplerin sınıf ve method tanımlarında parametre olarak kullanılmasını sağlayan bir teknolojidir. Bu teknolojinin kodlama yaparken programcıya kazandırdıkları kısaca şunlardır : 

  * Tip uyuşmazlığından kaynaklanan hataların çalışma zamanı (runtime) yerine derleme zamanında (compile time) yakalanabilmesi.
  * Tip dönüşümü ihtiyacının azaltılması.
  * Tipten bağımsız olarak algoritmaların bir seferde yazılması. Kod tekrarının önüne geçilmesi.
Basit bir örnek ile generics kullanımını görelim : [java]package net.orhanbalci.generics; import java.util.ArrayList; import java.util.List; public class Sepet<T> { private List<T> meyveler = new ArrayList(); public T meyveGetir(int index){ return meyveler.get(index); } public void meyveEkle(T yeniMeyve){ meyveler.add(yeniMeyve); } }[/java] Burada Sepet sınıfımız bir container sınıf olup içinde meyveleri barındırmakta. Fakat bu meyvenin türünü parametre ile belirleyebiliyoruz. Elma sepeti için ayrı armut sepeti için ayrı kod yazmıyoruz. Peki yazdığımız bu sınıftan nesnelerimizi nasıl oluşturuyoruz ona bakalım : [java] Sepet<Elma> elmaSepeti = new Sepet<Elma>(); Sepet<Armut> armutSepeti = new Sepet<Armut>(); [/java] Generic bir sınıf tanımından nesne oluştururken sınıf isminden sonra <> içerisinde tip argümanımızı veriyoruz. Elma ve Armut tip argümanlarıdır. Java 7.0 ile birlikte atama operatörünün (=) sağında kalan ifadelerde tip argümanları opsiyonel hale geldi. Yani derleyici tarafından tahmin edilebilir hale geldi. Yukarıdaki ifadeleri aşağıdaki şekilde de yazabiliriz : [java] Sepet<Elma> elmaSepeti = new Sepet<>(); Sepet<Armut> armutSepeti = new Sepet<>(); [/java] Peki generic olarak yazılan sınıflar daha önceki java versiyonunda yazılan kodla nasıl anlaşıyorlar? Yani geriye yönelik uyumluluğu nasıl sağlıyoruz onu inceleyelim. Generic sınıflardan tip argümanı olmadan üretilen sınıflara raw type adı veriliyor. Örneğin : [java] Sepet rawSepet = new Sepet(); [/java] Sepet sınıfımızı tip argümanı vermeden yukarıdaki şekilde kullanabiliriz. Bu kullanım generic sınıfların eski kodu kırmadan çalışmasını garanti eder. Bu kullanımda dikkat etmemiz gereken temel noktalar şunlardır : 
  1. Raw type değişkene parametrize bir değişken atanabilir. Örnek : [java] Sepet<Armut> armutSepeti = new Sepet<>(); Sepet rawSepet = new Sepet(); rawSepet = armutSepeti; [/java] 
  2. Parametrize değişkene raw type değişken atarsanız compiler'dan uyarı alırsınız. [java] Sepet rawSepet = new Sepet(); Sepet<Elma> elmaSepeti = new Sepet<>(); elmaSepeti = rawSepet; [/java] 
Generic sınıf tanımlamasına tanımlıyoruz da o kadar da generic olmasını istemiyor olabiliriz. Örneğin yukarıda tanımladığımız Sepet generic sınıfına tip parametresi olarak Integer geçebiliriz. Integer sepeti pek mantıklı bir soyutlama değil. Ben sepetimde sadece meyvelerin olmasını istiyorum derseniz "sınırlı tip parametreleri" ni kulllanabilirsiniz. Yukarıda örneklerde kullandığımız Elma, Armut sınıflarına göz atalım : [java] class Meyve{ } class Elma extends Meyve{ } class Armut extends Meyve{ }[/java] Sepet sınıfımızı sadece Meyve sınıfı ve alt sınıflarını parametre alacak şekilde düzenleyelim. Sınıfın imzasını aşağıdaki gibi değiştiriyoruz : [java] public class Sepet<T extends Meyve> [/java] Son durumda aşağıdaki gibi bir kullanım derleme hatası(java: type argument java.lang.Integer is not within bounds of type-variable T) verecektir : [java] Sepet<Integer> a = new Sepet<Integer>(); [/java] Yukaridaki kullanima gercek hayattan bir ornek verecek olursak sadece numeric tiplerle ilgilenen tip tanimi su sekilde yapilabilir: [java] abstract class NumericIslemci<Tip extends Numeric>{} [/java] Generic sınıflar ve mothodlar geliştirirken karıştırılan noktalardan bir tanesi de generic sınıfların miras (inheritance) ilişkisidir. Altın kural şu : tip parametrelerinin birbirinden miras alması generic tipin mirası için yeterli değildir. ** Yani Sepet<Meyve> tipi Sepet<Armut> tipinin üst sınıfı değildir.** Şöyle bir fonksiyonumuz olsun : [java] public boolean sepetKontrol(Sepet<Meyve> s){ return false; } [/java] Bu fonksiyonu şu şekilde çağıramayız : [java] sepetKontrol(new Sepet<Armut>()); [/java] [ad#Yazi Ici Buyuk]