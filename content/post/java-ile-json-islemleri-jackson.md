title: Java İle Json İşlemleri : Jackson
link: http://orhanbalci.net/tr/?p=1339
author: Orhan Balci
description: 
post_id: 1339
created: 2015/01/14 14:53:54
created_gmt: 2015/01/14 11:53:54
comment_status: open
post_name: java-ile-json-islemleri-jackson
status: publish
post_type: post

# Java İle Json İşlemleri : Jackson

Jackson kütüphanesi Java ile JSON işlemek için kullanışlı bir kütüphane. Bu makalede kütüphanenin temel işlemlerini göstermeye çalışacağım. Öncelikle işleyeceğimiz JSON örneğini verelim: [javascript] { "sebzeler" : [{ "sebze" : "marul", "gram" : 100 }, { "sebze" : "domates", "gram" : 100 }, { "sebze" : "salatalık", "gram" : 100 } ], "zeytinyağı" : true, "sirke" : false, "limon" : true } [/javascript] Jackson kütüphanesini temel olarak üç değişik şekilde kullanabiliriz. Bunlar : 

  1. Streaming API : 
[java] import com.fasterxml.jackson.core.JsonFactory; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.JsonToken; import java.io.FileInputStream; import java.io.IOException; public class JacksonStreamingSample { public static void main(String[] args) { JacksonStreamingSample jss = new JacksonStreamingSample(); jss.jsonStreamingExample(); } public void jsonStreamingExample() { try { JsonFactory jf = new JsonFactory(); jf.enable(JsonParser.Feature.ALLOW_COMMENTS); FileInputStream fis = new FileInputStream(getClass().getClassLoader().getResource("salata.json").getFile()); JsonParser jp = jf.createParser(fis); jp.nextToken(); while (jp.nextToken() != JsonToken.END_OBJECT) { String fieldName = jp.getCurrentName(); jp.nextToken(); //System.out.println(fieldName); String sebzeAdi = new String(""); double sebzeGramaj = 0.0; if ("sebzeler".equals(fieldName)) { while(jp.nextToken() != JsonToken.END_ARRAY){ String fName = jp.getCurrentName(); // fieldname token //jp.nextToken(); //value token if("sebze".equals(fName)){ jp.nextValue(); sebzeAdi = jp.getValueAsString(); } else if("gram".equals(fName)){ jp.nextValue(); sebzeGramaj = jp.getValueAsDouble(); } if(!sebzeAdi.isEmpty() && sebzeGramaj!= 0.0){ System.out.printf("Salatada %s gram %s var%n", sebzeGramaj, sebzeAdi); sebzeAdi = ""; sebzeGramaj = 0.0; } } } else if("zeytinyağı".equals(fieldName)){ boolean hasZeytinyagi = jp.getValueAsBoolean(); System.out.printf("Salatada zaytinyagi %s%n", hasZeytinyagi ? "var" : "yok"); } else if("sirke".equals(fieldName)){ boolean hasSirke = jp.getValueAsBoolean(); System.out.printf("Salatada sirke %s%n", hasSirke ? "var" : "yok"); } else if("limon".equals(fieldName)){ boolean hasLimon = jp.getValueAsBoolean(); System.out.printf("Salatada limon %s%n", hasLimon ? "var" : "yok"); } } } catch (IOException e) { e.printStackTrace(); //To change body of catch statement use File | Settings | File Templates. } } } [/java] Örnekten de anlaşılacağı üzere streaming api kullanımı biraz zor ve karışık bir api. Avantajı ise büyük boyutlu veriden istenilene kısa sürede ulaşılmasını sağlıyor. İşlemeniz gereken mb mertebesinde veya daha büyük bir json verisi varsa kullanmak mantıklı olacaktır. Pek kullanışlı bulmadım. Token vs. gibi kavramlar ilk kullanan için kafa karıştırıcı. 
  2. Tree Model API :
[java] public void jsonTreeModelExample() { ObjectMapper om = new ObjectMapper(); om.enable(JsonParser.Feature.ALLOW_COMMENTS); try { FileInputStream fis = new FileInputStream(getClass().getClassLoader().getResource("salata.json").getFile()); JsonNode rootNode = om.readTree(fis); Iterator<String> fieldNames = rootNode.fieldNames(); while (fieldNames.hasNext()) { String next = fieldNames.next(); if (rootNode.get(next).isValueNode()) { //object veya array node değil System.out.printf("Salatada %s %s%n", next, rootNode.get(next).booleanValue() ? "var" : "yok"); } else if (rootNode.get(next).isArray()) { // array node Iterator<JsonNode> arrayElements = rootNode.get(next).elements(); while (arrayElements.hasNext()) { JsonNode n = arrayElements.next(); if (n.isObject()) { System.out.printf("Salatada %s gram %s var%n", n.get("gram").doubleValue(), n.get("sebze").textValue()); } } } } } catch (IOException e) { e.printStackTrace(); } }[/java] Tree model api ise tüm verinin diskten okunup bir ağaç olarak ram de tutulmasına olanak sağlıyor. Bu ağaç üzerinde klasik ağaç algoritmalarını kullanarak istenilen veriye erişmek mümkün. Bu yöntemle çok büyük boyutlu verilerin işlenmesi bellek kullanımı açısından verimli olmayacaktır. Streming API a göre Nispeten daha anlaşılabilir bir api. küçük boyutlu json verilerinin sadece belirli bir bölümüne ulaşmak istiyorsanız tercih edebilirsiniz. 
  3. POJO <-> JSON Mapping API
[java] public class Salata{ private static class Sebze{ private String sebze; private int gram; public Sebze() { } int getGram() { return gram; } void setGram(int gram) { this.gram = gram; } String getSebze() { return sebze; } void setSebze(String sebze) { this.sebze = sebze; } @Override public String toString() { return String.format("Salatada %d gram %s var", gram, sebze); } }; public Salata(){ } Sebze[] getSebzeler() { return sebzeler; } void setSebzeler(Sebze[] sebzeler) { this.sebzeler = sebzeler; } boolean isZeytinyağı() { return zeytinyagi; } void setZeytinyağı(boolean zeytinyagi) { this.zeytinyagi = zeytinyagi; } boolean isLimon() { return limon; } void setLimon(boolean limon) { this.limon = limon; } boolean isSirke() { return sirke; } void setSirke(boolean sirke) { this.sirke = sirke; } @Override public String toString() { StringBuilder sb = new StringBuilder(); for (int i = 0; i < sebzeler.length; i++) { Sebze sebze = sebzeler[i]; sb.append(sebze); sb.append("\n"); } sb.append(String.format("Salatada sirke %s\n", isSirke() ? "var" : "yok")); sb.append(String.format("Salatada zeytinyağı %s\n", isZeytinyağı() ? "var" : "yok")); sb.append(String.format("Salatada limon %s\n", isLimon()? "var" : "yok")); return sb.toString(); } private Sebze[] sebzeler; private boolean zeytinyagi; private boolean limon; private boolean sirke; }; [/java] [java] public void jsonObjectMapperExample(){ ObjectMapper om = new ObjectMapper();