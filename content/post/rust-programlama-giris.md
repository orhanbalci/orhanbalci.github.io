title: Rust Programlama Giris
link: http://orhanbalci.net/tr/?p=1404
author: admin
description: 
post_id: 1404
created: 2015/07/09 00:10:35
created_gmt: 2015/07/08 21:10:35
comment_status: open
post_name: rust-programlama-giris
status: publish
post_type: post

# Rust Programlama Giris

C/C++ dillerinin gelisiminden bu yana sistem programlama dillerinde uzunca bir sure yenilik olmamisti. Son donemde Google ve Mozilla'nin ise el atmasiyla bu alanda yeni diller ve teknolojiler ortaya cikti. Bunlardan Go dili daha erken yola cikip daha cok yol almasina karsilik Mozilla tarafindan gelistirilen Rust dili de yakin donemde 1.0 surumuyle olgunluga eristi diyebiliriz. Henuz cok fazla kullanici kitlesi olmamakla birlikte GitHub uzerinde Rust diliyle gelistirilmis proje sayisi gunden gune artiyor. Peki Rust dilinin cozmeye calistigi problem ne? Rust sistem programlamanin esnekligini ve hizini kaybetmeden bu esneklikten kaynaklanan bellek yonetimiyle ilgili hatalari minimuma indirmeye calisiyor. Garbage collector'un hantalligi olmadan daha guvenli bir kaynak yonetimi modeli sunarak C/C++ dillerinde sikca karsilastigimiz "pointer double freeing" ve "heap corruption" hatalarinin onune geciyor. Bunun yaninda guvenli kaynak yonetimi guvenli multuthreaded kod manasina geliyor. Bu konuda ortaya koydugu "ownership","move semantics", "borrowing" ve "lifetime" kavramlarina yazi dizisinin devaminda sikca deginecegim. Ek olarak ciddi manada fonksiyonel programlamaya yonelik yapilar var. Fonksiyonlar birinci sinif vatandas ve closure yapilari mevcut. Iterator uzerinden map, filter, fold kavramlari gerceklenebiliyor.  Bastan soyleyeyim gelisimi devam eden bir dil oldugu icin unstable olan cok ozelligi var. Buna ek olarak tam manasiyla olgunlasmis bir gelistirme ortami yok. Gelistirme ortami olarak su araclari kullaniyorum : 

  1. Rust : Oncelikle dile ait compiler ve temel kutuphaneleri yuklemeniz gerekiyor. [Buradan ](http://www.rust-lang.org/)indirebilirsiniz. 
  2. Atom Editor : JavaScript tabanli gelistirilebilir text editor. [Suradan ](https://atom.io/)indirilebilir . Eklentiler sayesinde neredeyse tum dillerde gelistirme destegi saglamak mumkun. Rust gelistirmek icin **language-rust**,**racer**,**rust-api-docs-helper** paketlerini kurdum. Ayrica komut satirina editor icinden erismek icin **terminal-status** paketini kurdum. Yazdiginiz programi derlemek icin buna ihticainiz olacak
  3. Racer : Rust icin yazilmis en olgun kod tamamlayicisi. Rust ile yazilmis. Binary distribution bulamadim. [Github'dan ](https://github.com/phildawes/racer)indirip kendiniz derleyebilirsiniz.
  4. Cargo : Rust paket yoneticisi. Temel bir Rust proje catisi olusturmak ve bunu yonetmek icin gelistirilmiz bir yazilim. Racer aracini bununla derleyebilirsiniz. [Buradan ](https://crates.io/)indirebilirsiniz.
Kaynak kod dosya uzantisi olarak **rs** kullaniyoruz. Derleme komutumuz ise **rustc kaynak_dosya** seklinde. Adettendir kucuk bir programla acilisi yapalim :  Ornegimiz kucuk olmasina karsin dilin temel sentaks ozelliklerini gosteriyor. Satir satir aciklayalim. ilk satirda bir fonksiyon tanimi goruyoruz : [java]fn factorial(x : u32) -> u32{[/java] sentaks `fn fonksiyon_ismi(parametre_adi : parametre_tipi) -> donus_parametre_tipi` seklinde. factorial fonksiyonunun govdesini olusturan bloga pattern matcher deniliyor. Fonksiyonel programlamaya ait bir paradigma olan pattern matching karmasik if else ifadelerinin yerine kullaniliyor. [java]match x { 0 => 0, 1 => 1, _ => x * factorial(x-1) }[/java] Bu kod parcasi fonksiyona verilen parametreyi eslestirip buna karsilik fonksiyon ciktisini veriyor. Dikkatinizi cekmesi gereken bir diger husus ise return ifadesinin olmayisi. Rust dilinde yazdiginiz hersey aslinda bir ifade (statement) yani bir deger donuyor. Bunu bir deyime (expression) donusturmek icin sonuna ; koymaniz yeterli. Deyimler ise herhangi bir deger donmezler. Dolayisiyla bir fonksiyonun donus degeri sonunda ; olmayan son ifadenin donus degeri oluyor. Ornekde de goreceginiz uzerine match ifadesinin sonunda ; yok dolayisiyla fonksiyonun donus degeri match ifadesinin donus degeridir. Rust programlarinin giris fonksiyonu imzasi su sekilde kodumuz buradan calismaya basliyor. Gayet sade: [java] fn main (){ [/java] Rust yazmaya basladigimda gordugum en guzel ozellik tip sistemiydi. Benim bildigim dillerin cogunda tip isimleri ile hafizada kapladiklari alan boyutlari arasinda herhangi bir kopru yoktu. Rust bu isimlendirmeye son vererek degisken tiplerine hafizada kapladigi boyutlarin ismini vermis gayet anlasilir oldugunu dusunuyorum. Ayrica variable decleration sentaksi C ailesinden farkli tip adi degisken adindan sonra kullaniliyor. Nispeten daha genc dillerde geneldu bu yaklasim secilmis. Go'da da buna benzer bir yaklasim var. Nedeni [surada ](http://blog.golang.org/gos-declaration-syntax)aciklanmis. Bana gayet mantikli geldi kullanmasi da daha kolay. Rust da sentaks su sekilde [java] let test_number : u32 = 5; [/java] Burada u32 unsigned integer 32 bit tipidir. Gayet kendini aciklayan bir tip ismi sanirim. Primitive tiplere [buradan ](https://doc.rust-lang.org/book/primitive-types.html)ulasabilirsiniz. Son olarak basit bir output ifadesi var. Burada yine dikkati ceken println ifadesinin sonudaki ! isareti. Bu tarz ifadeler Rust da makro olarak tanimlanmis. Makrolara da ilerki yazilarimda ayrintili olarak deginecegim. Bu arada ingilizce ile arasi iyi olanlar icin Rust resmi tutorialina [buradan ](http://rustbyexample.com/)ulasabilirsiniz. [ad#Yazi Ici Buyuk]