title: Google Java Kütüphanesi : Guava Functions Predicates
link: http://orhanbalci.net/tr/?p=1222
author: admin
description: 
post_id: 1222
created: 2013/03/18 14:45:18
created_gmt: 2013/03/18 11:45:18
comment_status: open
post_name: google-java-kutuphanesi-guava-functions-predicates
status: publish
post_type: post

# Google Java Kütüphanesi : Guava Functions Predicates

Genelde yazıları Türkçe kaleme almaya çalışıyorum fakat predicate karşılığını tam bulamadığım için başlık yarı Türkçe yarı İngilizce oldu. Guava'nın c++ STL tarzı programlamayı olanaklı hale getiren sınıflarını inceleyelim. STL tarzı programlama derken Fonksiyonel Programlama'dan bahsediyorum aslında. Fonksiyonel Programlama paradigması yazılımın merkezine işlemleri yani fonksiyonları alır. Nesne odaklı mimarinin tersine veri yapıları arka plandadır. Guava ekseninde konuşacak olursak fonksiyonlar ve predicate'ler genellikle koleksiyonları filtrelemek (predicateler aracılığıyla) ve elemanları farklı elemenlara dönüştürmek (fonksiyonlar aracılığıyla) amacıyla kullanılıyorlar. Öncelikle predicatelerin nasıl tanımlanacağını öğrenelim. Bunun için **Predicate** arayüzünü kullanacağız. [java] package net.orhanbalci.guavasamples; import com.google.common.base.Joiner; /** * Kullanıldığında http://orhanbalci.net adresi referans verilmelidir */ public class AccountBalance { private double balance; private int id; public AccountBalance(double balance, int id) { this.balance = balance; this.id = id; } public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return Joiner.on("->").join(id,balance); } } [/java] Örneğimiz için kullanacağımız hesap özeti entity sınıfı yukarıdaki gibi. Müşteri hesaplarından bakiyesi 0'dan büyük olanları filtrelemek istiyoruz. Filtre kriterimizi yazacağımız predicate sınıfta belirtiyoruz.  [java] package net.orhanbalci.guavasamples; import com.google.common.base.Predicate; /** * Kullanıldığında http://orhanbalci.net adresi referans verilmelidir */ public class AccountBalanceGreaterThanZeroPredicate implements Predicate<AccountBalance> { @Override public boolean apply(AccountBalance accountBalance) { return accountBalance.getBalance() > 0; } } [/java] Şimdi de hesap özeti nesnelerinden oluşan bir listeyi istediğimiz kriterlere göre filtreden geçirelim : [java] package net.orhanbalci.guavasamples; import com.google.common.base.Joiner; import com.google.common.collect.Iterators; import com.google.common.collect.UnmodifiableIterator; import java.util.ArrayList; import java.util.List; /** * Kullanıldığında http://orhanbalci.net adresi referans verilmelidir */ public class GuavaPredicates { private static List<AccountBalance> accountBalances = new ArrayList<AccountBalance>(); static { accountBalances.add(new AccountBalance(1000,1)); accountBalances.add(new AccountBalance(2000,2)); accountBalances.add(new AccountBalance(-3000,3)); } public static void main(String[] args) { UnmodifiableIterator<AccountBalance> it = Iterators.filter(accountBalances.iterator(), new AccountBalanceGreaterThanZeroPredicate()); System.out.println(Joiner.on(",").join(it)); } } [/java] Hesap özeti nesnelerinden oluşan bir listeyi filtrelemek için **Iterators** sınıfının filter static methodundan faydalandık. Burada **filter** methodunun dönüş değerinin **UnmodifiableIterator** olduğuna dikkat edelim. **filter** methodları uygulandıkları koleksiyonların read-only görünümlerini dönerler. Orjinal koleksiyonlar üzerinde değişiklik yapmazlar. **Predicate** sınıfları tek başlarına iş görebildikleri gibi "**or**" ve "**and**" lenerek birlikte de çalışabilirler. Bunun için **Predicates** sınıfının **and**, **or** statik methodları kullanılmalıdır. Fonksiyon nesnelerinin kullanımı da oldukça benzer. Bunun için de **Function **interface'ini gerçeklemek yeterli olacaktır. Örneğin sayıların karelerini bulan bir fonksiyon tanımı : [java] package net.orhanbalci.guavasamples; import com.google.common.base.Function; public class SquareFunction implements Function<Integer,Integer> { @Override public Integer apply(Integer input) { return input * input; } } [/java] Bu fonksiyonu sayılardan oluşan bir listeye uygulamak için Iterables.Transaform statik methodunu kullanıyoruz. Çıktıyı oluşturmak için yine Guava,2dan yararlanarak Joiner sınıfını kullanıyoruz : [java] package net.orhanbalci.guavasamples; import com.google.common.base.Joiner; import com.google.common.collect.Iterables; import java.util.Arrays; import java.util.List; public class GuavaFunctions { public static void main( String[] args ) { List<Integer> numbers = Arrays.asList( 1,2,3,4,5,6); System.out.println(Joiner.on(":").join( Iterables.transform( numbers, new SquareFunction()))); } } [/java] Kod parçasının çıktısı şu şekilde olacaktır : `1:4:9:16:25:36`