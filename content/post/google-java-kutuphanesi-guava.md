title: Google Java Kütüphanesi : Guava String İşlemleri
link: http://orhanbalci.net/tr/?p=1205
author: admin
description: 
post_id: 1205
created: 2013/03/17 00:22:59
created_gmt: 2013/03/16 21:22:59
comment_status: open
post_name: google-java-kutuphanesi-guava
status: publish
post_type: post

# Google Java Kütüphanesi : Guava String İşlemleri

Online hayatımızın merkezinde yer alan google araçlarını kullanmayan yoktur. Arama motoru olsun mail olsun rss reader olsun (her ne kadar sonlandırılıyor olsada) gayet başarılı, stabil çalışan ürünler. Bu yazının amacı google ürünlerini tanıtmaktan ziyade bu ürünlerin üzerine bina edildiği çekirdek Java kütüphanesini sizlere tanıtmak. Google ürünleri çok farklı yazılım dilleri ile geliştirilmesine rağmen Java bu diller arasında sivrilmeyi başarmış durumda. Google mühendisleri farklı projelerde benzer amaçlara yönelik benzer kodların yazıldığını farkedince ortak çekirdek bir kütüphane oluşturmak istemişler. Önceleri işe yarayan methodların biraraya getirilmesi şeklinde ilerleyen proje sonra daha şık bir şekilde yapılandırılmış. Daha sonra da tüm dünyanın kullanımına açmak için projeyi open-source lisanslamışlar. Ha bu arada projenin adı **Guava**. Şu linkten proje mühendislerinin ağzından projeyi dinleyebilirsiniz. <http://www.infoq.com/presentations/Guava> Peki Guava'yı neden bloğuma taşıdım. Benim için Guava 2 şeyi ifade ediyor. 

  1. **Akıcı Kod Geliştirme**
  2. **Temiz Kod Geliştirme**
Girizgahtan sonra Guava'nın nimetlerine gelelim. Çekirdek kütüphane olduğunda String Utility sınıflarından, Immutable Collection sınıflarına çok farklı konulara şık çözümler sunuyor kütüphane. Gruplar halinde Guava'nın getirdiklerini inceleyelim. 
  1. **String Yardımcı Özellikleri** Javanın standart String birleştirme ve ayrıştırma methodları çoğu zaman işimizi görmez. Bunların etrafına çeşitli yardımcı statik metodlar geliştiririz. Google mühendislerinin bu soruna çözümü Joiner ve Splitter sınıfları olmuş. Kütüphanenin ne kadar sezgisel (intuitive) tasarlandığı sınıf isimlerinden kendini göstermekte. Örneğin farklı stringleri birleştirmek için Joiner sınıfını kullanıyoruz: [java] String [] fruits = new String[]{"elma","armut","nar",null,"mandalina",}; String fruitsJoined = Joiner.on( ',' ).skipNulls().join( fruits ); System.out.println(fruitsJoined ); [/java] Burada akışkan bir kodlama elde etmek için Joiner sınıfına constructor koymak yerine static bir method (**on()**) kullanarak Joiner nesnesi elde ediliyor. Arkasından bu nesnenin nasıl davranacağı konfigüre ediliyor (**skipNulls()**). En sonda asıl yapılacak işlem bildiriliyor (**join()**). Diğer yardımcı sınıfların tasarımında da kullanılan bu kalıba kütüphanenin tasarımcıları tarafından **"Utility Object Pattern"** ismi verilmiş. Beni Guava'da en çok etkileyen tasarım bu oldu açıkçası. Kesinlikle akışkan (fluent) ve sezgisel (intuitive) yazılım geliştirmeyi sağlıyor. Joiner sınıfını map sınıfları üzerinde kullanmak ise tam bir keyif. Hemen hemen tüm yazılım geliştiriciler debug amaçlı map nesneleri için **toString()** methodu geliştirmiştir. Örnekte Guavalı ve Guavasız iki adet MapPrinting method var hangisi daha iyi kararı size bırakıyorum : [java] package net.orhanbalci.guavasamples; import com.google.common.base.Joiner; import javax.print.attribute.SetOfIntegerSyntax; import java.util.Map; import java.util.Set; import java.util.TreeMap; /** * Kullanıldığında http://orhanbalci.net adresi referans verilmelidir */ public class GuavaMapJoiner { private static Map<Integer,String> numbersMap = new TreeMap<Integer, String>(); static { numbersMap.put(1,"bir"); numbersMap.put(2,"iki"); numbersMap.put(3,"üç"); numbersMap.put(4,"dört"); } public static void main(String[] args) { MapPrintingWithGuava(); MapPrintingWithoutGuava(); } private static void MapPrintingWithGuava() { System.out.println(Joiner.on("|").withKeyValueSeparator("->").join(numbersMap)); } private static void MapPrintingWithoutGuava() { Set<Integer> numbersKeySet = numbersMap.keySet(); StringBuilder sb = new StringBuilder(); for (Integer numberKey : numbersKeySet) { sb.append(numberKey +"->"+numbersMap.get(numberKey) + "|"); } sb.setLength(sb.length()-1); System.out.println(sb.toString()); } } [/java] Stringleri birleştirdikten sonra sıra ayırmaya geldi. Yine **"Utility Object Pattern"** den faydalanıyoruz : [java] Iterable<String> splitedFruits = Splitter.on('=').split("havuç=karpuz=muz=çilek"); for (String fruit : splitedFruits) { System.out.println(fruit); } [/java] Düzenli bir şekilde birleştirdiğimiz map elemanlarını tekrar kolay bir şekilde Map sınıfı olarak ayrıştırmamız mümkün : [java] package net.orhanbalci.guavasamples; import com.google.common.base.Joiner; import com.google.common.base.Splitter; import java.util.Iterator; import java.util.Map; import java.util.Set; import java.util.TreeMap; public class GuavaSplitter { private static Map<Integer,String> numbersMap = new TreeMap<Integer, String>(); static { numbersMap.put(1,"bir"); numbersMap.put(2,"iki"); numbersMap.put(3,"üç"); numbersMap.put(4,"dört"); } public static void main(String[] args) { String joinedNumbers = Joiner.on("|").withKeyValueSeparator("->").join(numbersMap); Map<String,String> splittednumbersMap = Splitter.on('|').withKeyValueSeparator(Splitter.on("->")).split(joinedNumbers); Set<String> numbersSet =splittednumbersMap.keySet(); Iterator<String> it = numbersSet.iterator(); while(it.hasNext()) { String key = it.next(); System.out.println("Key : " \+ key + " Value : " \+ splittednumbersMap.get(key)); } } } [/java] Çoğumuz text dosyadan olsun, excel dosyasından olsun okunmuş sabit uzunluklu (fixed-length) string kümeleriyle uğraşmışızdır. Bu tarz stringleri elemanlarına ayrıştırmak için **Splitter.fixedLength() **methodunu kullanıyoruz : [java] public static void guavaFixedWidthStringSplit() { String s = "Ali Ahmet Ayşe " \+ "Salih Sedat Osman "; System.out.println(Joiner.on("->").join(Splitter.fixedLength(6).split(s))); } [/java] 
DEVAM EDECEK  [ad#Yazi Ici]