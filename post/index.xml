<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Orhan Balci</title>
    <link>http://orhanbalci.github.io/post/index.xml</link>
    <description>Recent content in Posts on Orhan Balci</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>tr-TR</language>
    <lastBuildDate>Wed, 27 Jan 2016 15:29:31 +0800</lastBuildDate>
    <atom:link href="http://orhanbalci.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rust Program Düzeni : Modüller</title>
      <link>http://orhanbalci.github.io/post/rust-program-duzeni-moduller/</link>
      <pubDate>Wed, 27 Jan 2016 15:29:31 +0800</pubDate>
      
      <guid>http://orhanbalci.github.io/post/rust-program-duzeni-moduller/</guid>
      <description>

&lt;h1 id=&#34;rust-program-düzeni-modüller&#34;&gt;Rust Program Düzeni : Modüller&lt;/h1&gt;

&lt;p&gt;Gelistiridigimiz projeler buyudukce bu karmasikligi yonetmek icin dillerin bize sagladigi soyutlama ve paketleme mekanizmalarini kullaniyoruz. Javada package, C++ da namespace kavramlari birbiriyle ilintili olan kod kumelerini gruplamaya yarayan yapilar. Rust dilinde ayni gorev icin moduller kullaniliyor. Modül tanimlamak icin &lt;code&gt;mod&lt;/code&gt; anahtar kelimesi kullaniliyor. Yeri gelmisken deginmeden edemeyecegim Rust anahtar kelime konusunda diger dillere gore basitlik acisindan onde. Sık kullanılan anahtar kelımeler oldukca kısa tutulmus. Ornegin fonksiyon icin &lt;code&gt;fn&lt;/code&gt;, modul icin &lt;code&gt;mod&lt;/code&gt;, public icin &lt;code&gt;pub&lt;/code&gt;. Ilk olarak modul tanimlamayi ogrenelim. Ornegin bir oyun yazdigimizi dusunelim. Matematik hesaplamalarda kullanacagimiz yapilari &lt;code&gt;math&lt;/code&gt; modulune, ai algoritmalarimizi da &lt;code&gt;ai&lt;/code&gt; modulune koyalim. Tabi bu modullere ait alt moduller de tanimlayalim :  Bu modulleri game_sample projemizde main.rs dosyasinda tanimliyoruz. Projemizin klasor yapisi kabaca su sekilde oluyor.  Aklimiza gelen ilk soru tum modulleri ayni dosya icerisine mi yazacagiz oluyor. Bu sorunu cozmek icin modul ismi ile ayni isimde bir .rs dosyasi olusturuyoruz ve modul icerigini bu dosyaya tasiyoruz. Bu ilk cozum. Math ve a.i modullerini kendi dosyalarina tasiyalim. Modul isimlendirirken snake_case isimlendirme yontemini kullaniyoruz. Tamamen kucuk harfleri kullanip kelimeler arasina _ koyuyoruz. main.rs dosyamizi duzenliyoruz. modul iceriklerini tasidigimiz icin burada sadece &lt;code&gt;mod math; mod ai;&lt;/code&gt; satirlari kaliyor. Duzenlemeden sonra main.rs math.rs ai.rs dosyalarimiz :  Dikkat etmemiz gereken husus hem main.rs icinde hem modul_adi.rs dosyasi icinde ayni modul tanimini tekrarlamamak. Bu adimi yaptiktan sonra klasorumuzun son hali su sekilde oluyor :  Aslinda bir nebze de olsa karmasikliktan kurtulduk. Peki math ve ai modullerinin alt modullerini nasil dosyalamaliyiz. Onlari da ayni sekilde kendi dosyalarina alabilirmiyiz ? ai.rs dosyasinin icerigini su sekilde guncelleyelim ve bos bir agent.rs dosyasini olusturalim.  Son durumda dosyalarimiz su sekilde oluyor :  &lt;code&gt;cargo build&lt;/code&gt; komutu ile projemizi derlemeye calisinca su sekilde bir hata aliyoruz.  Hata mesaji aslinda ne yapmamiz gerektigini bize gosteriyor. Dallanmis modullerin bulundugu durumda hepsini ayni klasor icinde kendi dosyalarina alamiyoruz. Bu durumda Rust un ikinci modul tanimlama konfigurasyonunu kullanmamiz gerekiyor. Modul ismiyle ayni bir alt klasor olusturup icine &lt;code&gt;mod.rs&lt;/code&gt; isminde kaynak dosyasi olusturuyoruz. ai klasoru olusturup icine mod.rs dosyasini olusturalim ve icerigini ai.rs dosyasindan kopyalayalim. Son durumda klasorumuzun yapisi su sekilde olusuyor. Modul yapisini klasor yapisiyla eslestirmis oluyoruz.  Rust ile gelistirilmis projeleri incelerken her alt klasorun altinda mod.rs dosyalari goreceksiniz. Bunlarin tamami modul tanim dosyalaridir. [ad#Yazi Ici Buyuk]&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rust Cheatsheet</title>
      <link>http://orhanbalci.github.io/post/rust-cheatsheet/</link>
      <pubDate>Fri, 18 Dec 2015 15:29:31 +0800</pubDate>
      
      <guid>http://orhanbalci.github.io/post/rust-cheatsheet/</guid>
      <description>

&lt;h1 id=&#34;rust-cheatsheet&#34;&gt;Rust Cheatsheet&lt;/h1&gt;

&lt;p&gt;Rust ile ilgili hatirlamak amacli notlardir :&lt;/p&gt;

&lt;h1 id=&#34;cargo-komutlari&#34;&gt;Cargo Komutlari&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Yeni proje olusturmak icin &lt;code&gt;cargo new proje_adi --bin&lt;/code&gt; komutunu kullaniyoruz&lt;/li&gt;
&lt;li&gt;carate aramak icin &lt;code&gt;cargo search crate_adi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;test build run icin &lt;code&gt;cargo test&lt;/code&gt; &lt;code&gt;cargo build&lt;/code&gt;&lt;code&gt;cargo run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cargo alt komutlarini listelemek icin &lt;code&gt;cargo --list&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;string&#34;&gt;String&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&amp;str; -&amp;gt; String donusumu String::from(&amp;str;) seklinde yapiliyor&lt;/li&gt;
&lt;li&gt;substring almak icin String yapisinin [begin_index..end_index] operatoru kullanilabilir&lt;/li&gt;
&lt;li&gt;Herhangi bir tipi String e cevirmek icin o tipin to_string() fonksiyonunu kullanabilirsiniz &lt;code&gt;num.to_string()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Herhangi bir Stringi diger tiplere cevirmek icin&lt;code&gt;parse::().unwrap()&lt;/code&gt; fonksiyonunu kullaniyoruz&lt;/li&gt;
&lt;li&gt;Stringi u8 vectore cevirmek icin &lt;code&gt;into_bytes&lt;/code&gt; fonksiyonunu kullaniyoruz&lt;/li&gt;
&lt;li&gt;byte arraydan Stringe donusum &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; fonksiyonu ile gerceklesiyor. Stringinizde unicode karakterler varsa istenmeyen sonuclar alabilirsiniz&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;collections&#34;&gt;Collections&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;HashMap kullanimi icin use std::collections::HashMap&lt;/li&gt;
&lt;li&gt;HashMap eklemek icin insert(key,value) apisi kullaniliyor&lt;/li&gt;
&lt;li&gt;HashMap de varmi kontrolu contains_key(key) apisi ile oluyor&lt;/li&gt;
&lt;li&gt;HashMap de value get(key) ile alinabiliyor Option donuyor unwrap yapmak gerekiyor&lt;/li&gt;
&lt;li&gt;Vec son elemani &lt;code&gt;last()&lt;/code&gt; ile aliyoruz. eger son eleman uzerinde degisiklik yapmak istersek &lt;code&gt;last_mut()&lt;/code&gt; kullanmaliyiz&lt;/li&gt;
&lt;li&gt;Vec iterasyonlarinda &lt;code&gt;i in vec.iter()&lt;/code&gt; yerine okunaklilik acisindan &lt;code&gt;i in &amp;amp;vec;&lt;/code&gt; kullaniyoruz&lt;/li&gt;
&lt;li&gt;Elimizde Vec varsa bunu tek bir stringde birlestirmek icin concat() ve join() fonksiyonlarini kullaniyoruz&lt;/li&gt;
&lt;li&gt;Vec nesnesinden 2 serli 3 erli gruplar elde etmek icin &lt;code&gt;chunks&lt;/code&gt; fonksiyonunu kullaniyoruz. String icin bu yok maalesef.&lt;/li&gt;
&lt;li&gt;slice parametreleri ffi interfaceden gecmek icin as_ptr kullaniyoruz&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;iterator&#34;&gt;Iterator&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Azalan bir iterator elde etmek icin &lt;code&gt;(a..b).rev()&lt;/code&gt; kullaniyoruz&lt;/li&gt;
&lt;li&gt;Iterasyonda ilk n elemani atlamak icin &lt;code&gt;iter().skip(n)&lt;/code&gt;kullaniyoruz&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;test&#34;&gt;Test&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Floating point sayilar icin esitlik makrosu bulunmuyor. approx cratesi kulanilabilir&lt;/li&gt;
&lt;li&gt;#[macro use] extern crate approx; partial_eq!()&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rust Dökümantasyon</title>
      <link>http://orhanbalci.github.io/post/rust-dokumantasyon/</link>
      <pubDate>Wed, 09 Dec 2015 15:29:31 +0800</pubDate>
      
      <guid>http://orhanbalci.github.io/post/rust-dokumantasyon/</guid>
      <description>

&lt;h1 id=&#34;rust-dökümantasyon&#34;&gt;Rust Dökümantasyon&lt;/h1&gt;

&lt;p&gt;Rust kod dokumantasyonuna onem veren bir dil ve bunu default olarak desteklemekte. Yani Rust alet cantasini bilgisayarimiza yukledigimizde &lt;strong&gt;rustdoc&lt;/strong&gt; denilen kod yorumlarindan dokumantasyon olusturan yardimci yazilim da bilgisayarimiza yukleniyor. Bu araci &lt;code&gt;rustdoc kaynak_kod_dosyasi.rs&lt;/code&gt; seklinde kullanabiliriz yada Rust un proje yonetim araci Cargo ile &lt;code&gt;cargo doc&lt;/code&gt; seklinde de kullanabiliriz. Yazilim gelistirirken mutlaka guncel tutulan tek sey yazilim kaynak kodu oldugu icin dokumantasyonu kod yorumlarindan olusturmak tercih edilen bir uygulama. Bunu Java&amp;rsquo;da Javadoc, c++ da doxygen ile uyguluyoruz. Rust bu konuda &lt;a href=&#34;https://en.wikipedia.org/wiki/Markdown&#34;&gt;markdown&lt;/a&gt; denen standardi destekliyor. Yorum bloklari &lt;code&gt;///&lt;/code&gt; uclu slash ile normal yorum bloklarindan ayriliyor. Klasik bir dokumantasyon blogu sunun gibi oluyor :  Dokumantasyon icinde kod blogu gostermek istiyorsak (ozellikle fonksiyonumuzun ormek kullanimi gibi ornek kodlar ise yariyor) &lt;code&gt;kullaniyoruz. Ornegin :  Burada dikkat etmemiz gereken hususlardan bir tanesi `///` isaretlerinden sonra bosluk birakmamiz gerektigi sanirim Markup ile ilgili bir durum.&lt;/code&gt; isaretleri ile varsayilan olarak rust kodu sentaksi renklendiriliyor. Bunun disinda bir dilden kod blogu gosterecekseniz bunu belirtmeniz gerekiyor. Ornegin java kodu eklemek istiyorsaniz ```&lt;code&gt;java&lt;/code&gt; seklinde kullanmaniz gerekiyor. Yukaridaki ornekte aslinda bir diger ozelligi de kullanmis olduk. &lt;code&gt;#&lt;/code&gt; karakteri ile dokumantasyonda ana baslik, bolum olusturabiliyoruz.  Simdiye kadar anlattiklarimiz genellikle diger dokumantasyon araclariyla ortak olan kisimlardi. Rustdocu digerlerinden ayiran en buyuk ozellik testlerinizi dokumantasyon icine yazabiliyorsunuz. Yazdigimiz testler hem dokumantasyonu olusturuyor hem de unit test olarak cagrilabiliyor. Peki bunu nasil yapiyoruz. rustdoc bu konuda elimizi epey rahatlatiyor ornegin kodumuz bir main blogu icinde degilse kendi olusturuyor,bazi sik kullanilan compiler makrolarini koda ekliyor. Test kodunun compile olabilmesini fakat bu kodun tamaminin dokumantasyonda gorunmesini istemiyorsak istenmeyen satirlari &lt;code&gt;#&lt;/code&gt; isaretiyle kapatmamiz yeterli. Ornegin asagida bir fonksiyon ve dokumantasyonu icinde bir test casei yer almakta :  Dokumantasyon icindeki testleri &lt;code&gt;cargo test&lt;/code&gt; komutuyla kolaylikla cagirabiliyoruz. Bu komut tum modulu test edecektir. Sadece tek bir dosya icerisindeki testleri calistirmak istiyorsak &lt;code&gt;rustdoc --test kaynak_dosya.rs&lt;/code&gt; komutunu kullanmamiz yeterli. Dokumantasyon testlerinin en buyuk handikapi sadece kutuphane (library) tipindeki projelerde ise yaramasi. Calistirilabilir dosya urettiginiz projelerde ise yaramiyor. Son olarak &lt;code&gt;///&lt;/code&gt; isaretlemesi kendinden sonra gelen ifadeyi dokumente etmek icin kullniliyor. Bir blogu dokumante etmek icin &lt;code&gt;//!&lt;/code&gt; isaretlemesi kullaniliyor. Bunlara da genellikle module dokumantasyonu deniliyor.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rust Primitif Veri Yapilari Tuple ve Array</title>
      <link>http://orhanbalci.github.io/post/rust-primitif-veri-yapilari-tuple-ve-array/</link>
      <pubDate>Fri, 11 Sep 2015 15:29:31 +0800</pubDate>
      
      <guid>http://orhanbalci.github.io/post/rust-primitif-veri-yapilari-tuple-ve-array/</guid>
      <description>

&lt;h1 id=&#34;rust-primitif-veri-yapilari-tuple-ve-array&#34;&gt;Rust Primitif Veri Yapilari Tuple ve Array&lt;/h1&gt;

&lt;p&gt;Tuple yapilari birbirleriyle ilintili verileri bir arada tutmaya yarar. Struct yapilarindan farki alanlarinin isim etiketi olmamasidir. Verilere index yardimiyla erisilir. Imumutable yapilar olup sabit boyutludurlar. Fonksiyonlardan birden fazla deger donmekte, ayni anda birden fazla degiskene deger atamakta, pattern matching islemlerinde kullanicia kolaylik saglarlar. Fonksiyonel programlamaya has veriyapilaridir. Ornegin network baglantilarinda sikca beraber kullandigimiz ip ve port bilgileri icin bir tuple tanimlayalim ve kullanalim :  Temel kullanimi gordukten sonra pattern matching ile ne yapabiliriz buna bakalim. Ufak bir hesaplama fonksiyonu yazalim ve bu fonksiyona parametreleri bir tuple yardimiyla gecelim. Tuple su sekilde olsun &lt;code&gt;(komut,parametre1,parametre2)&lt;/code&gt; bir sonraki ornegimizde ise bir swap fonksiyonu yazarak tuple icindeki degerlerin yer degistirmesini gorelim. Burada &lt;code&gt;destructuring&lt;/code&gt; yani tuple veya struct icerisindeki degerlerin disariya cikarilmasi yontemini de kullanalim. c/c++ ta bu kavram olmadigi icin baslangicta garipseyebilirsiniz :  Ornekte 9. satirdaki ifade ile &lt;code&gt;arg&lt;/code&gt; tuple destructure edilerek elemanlari a,b degiskenlerine atanmistir. Tuplelara bu kadar degindikten sonra bir ornekle de array ve slice kullanimini gorelim. Array boyutlari compile time da bilinmek zorunda. Yani boyutu calisma zamaninda belirlenecek arrayler olusturulamiyor. Slice lar ise arraylarin alt bir araligini temsil eden yapilar. Slicelarin boyutu compile time de bilinmek zorunda degil. Array degisken tipi tanimi &lt;code&gt;[veri tipi;array boyutu]&lt;/code&gt; seklinde yapiliyor. Ilk deger atanirken &lt;code&gt;[deger1,deger2,deger3...degern]&lt;/code&gt; sentaksi yada tum elemanlara ayni degeri atamak icin &lt;code&gt;[atanacak deger; array boyutu]&lt;/code&gt; sentaksi kullanilabilir. Asagidaki ornek rust tutorialindan alinip biraz eklemeler yapilmistir :  15. ve 16. satirlarda bahsettigimiz array degisken tanimlamalari ve deger atamalari yer aliyor. &lt;code&gt;analyze_slice&lt;/code&gt; fonksiyonu slice isimli bir slice parametere aliyor. Bu slice mutable tanimlanmadigi icin fonksiyon icinde slice uzerinde herhangi bir guncelleme aypilamaz. 8. satirda tnimladigimiz &lt;code&gt;update_slice&lt;/code&gt; fonksiyonunda ise mutable bir slice parametresi gectigi icin slice uzerinde guncelleme yapabiliyoruz. 9. satirdaki for ifadesi de slicelari gezinmek icin guzel bir ornek teskil ediyor. [ad#Yazi Ici Buyuk]&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://orhanbalci.github.io/post/2009un-getirdikleri-2010dan-beklentiler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://orhanbalci.github.io/post/2009un-getirdikleri-2010dan-beklentiler/</guid>
      <description>

&lt;p&gt;title: 2009&amp;rsquo;un Getirdikleri 2010&amp;rsquo;dan Beklentiler
link: &lt;a href=&#34;http://orhanbalci.net/tr/?p=553&#34;&gt;http://orhanbalci.net/tr/?p=553&lt;/a&gt;
author: Orhan Balci
description:
post_id: 553
created: 2010/01/13 20:02:32
created_gmt: 2010/01/13 17:02:32
comment_status: open
post_name: 2009un-getirdikleri-2010dan-beklentiler
status: publish
post_type: post&lt;/p&gt;

&lt;h1 id=&#34;2009-un-getirdikleri-2010-dan-beklentiler&#34;&gt;2009&amp;rsquo;un Getirdikleri 2010&amp;rsquo;dan Beklentiler&lt;/h1&gt;

&lt;p&gt;Öyle nefis muhasebesi yapan birisi değilim. Kendisine hedef belirleyip sıkı sıkıya bu hedeflere sarılan birisi de sayılmam. Yeni yılın ilk ayının ortalarına gelmişken okuduğum bir blog girdisi kendimi sorgulamama sebep oldu. Geçtiğimiz yıl hayatımda ne gibi değişiklikler olduğunu ve yeni yılda kendimden ne beklediğimi yazmaya karar verdim. Önümüzdeki yıla kadar yaşarsak bu listenin neresinde olduğumuza bakarız hep birlikte.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;2009

&lt;ol&gt;
&lt;li&gt;Benim adıma 2009&amp;rsquo;un en önemli olayı nişanlanmam oldu :)&lt;/li&gt;
&lt;li&gt;Eski işyerim KaleTron&amp;rsquo;un KaTron oldu ve askerden dönmemle yeniden işe başladım&lt;/li&gt;
&lt;li&gt;Sonlarına doğru ekibe katıldığım MES projesini tamamladık.&lt;/li&gt;
&lt;li&gt;POTSIM projesine başladık. Hala bitiremedik :(&lt;/li&gt;
&lt;li&gt;NVIDIA PhysX kütüphanesiyle boğuştum&lt;/li&gt;
&lt;li&gt;Windows kullanmayı bıraktım, Ubuntu&amp;rsquo;ya terfi ettim&lt;/li&gt;
&lt;li&gt;Senenin ilk beş ayı Sarıyer&amp;rsquo;de, geri kalan kısmı Ümraniye&amp;rsquo;de geçti&lt;/li&gt;
&lt;li&gt;Proje Bülbül başladı&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;2010

&lt;ol&gt;
&lt;li&gt;2010 yılı içinde evlenmeyi planlıyorum (evlenmeyi planlayanı da ilk defa görüyorum) :)&lt;/li&gt;
&lt;li&gt;Yüksek lisansa başlamayı umuyorum&lt;/li&gt;
&lt;li&gt;Yeni bir programlama dili olarak Python öğrenmeyi planlıyorum&lt;/li&gt;
&lt;li&gt;Sene boyunca 50 kitap okumayı hedefliyorum. Listemde Jose Saramago, Asimov, Selim İleri, Refik Halid Karay var.&lt;/li&gt;
&lt;li&gt;Türkiye&amp;rsquo;de daha önce görmediğim bir şehri ziyaret etmek istiyorum. Bu şehir hakkında şu an hiç bir fikrim yok&lt;/li&gt;
&lt;li&gt;Blogumda aylık ortalama 5 yazı yayınlamayı amaçlıyorum&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://orhanbalci.github.io/post/2013-okuma-listesi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://orhanbalci.github.io/post/2013-okuma-listesi/</guid>
      <description>

&lt;p&gt;title: 2013 Okuma Listesi
link: &lt;a href=&#34;http://orhanbalci.net/tr/?p=1239&#34;&gt;http://orhanbalci.net/tr/?p=1239&lt;/a&gt;
author: Orhan Balci
description:
post_id: 1239
created: 2013/03/28 12:07:25
created_gmt: 2013/03/28 09:07:25
comment_status: open
post_name: 2013-okuma-listesi
status: publish
post_type: post&lt;/p&gt;

&lt;h1 id=&#34;2013-okuma-listesi&#34;&gt;2013 Okuma Listesi&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Programming In Scala

&lt;ul&gt;
&lt;li&gt;In Cold Blood&lt;/li&gt;
&lt;li&gt;Vakıf&amp;rsquo;ın Sınırı 5. Kitap&lt;/li&gt;
&lt;li&gt;Korkma Ben Varım&lt;/li&gt;
&lt;li&gt;Suskunlar&lt;/li&gt;
&lt;li&gt;Java Concurrency In Practice&lt;/li&gt;
&lt;li&gt;Dost Kazanma ve İnsanları Etkileme Sanatı&lt;/li&gt;
&lt;li&gt;Neşet Ertaş Kitabı&lt;/li&gt;
&lt;li&gt;Yönetim Örnek Vakalar&lt;/li&gt;
&lt;li&gt;Aile Bilgeliği&lt;/li&gt;
&lt;li&gt;Şeytan Ayrıntıda Gizlidir&lt;/li&gt;
&lt;li&gt;Alef&lt;/li&gt;
&lt;li&gt;Riyazu&amp;rsquo;s Salihin Muhtasar&lt;/li&gt;
&lt;li&gt;Biz İnsanlar&lt;/li&gt;
&lt;li&gt;Nuhun Gemisi&lt;/li&gt;
&lt;li&gt;Gençliğim Eyvah&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://orhanbalci.github.io/post/agva-goksu-motor-turu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://orhanbalci.github.io/post/agva-goksu-motor-turu/</guid>
      <description>

&lt;p&gt;title: Ağva-Göksu Motor Turu
link: &lt;a href=&#34;http://orhanbalci.net/tr/?p=1070&#34;&gt;http://orhanbalci.net/tr/?p=1070&lt;/a&gt;
author: Orhan Balci
description:
post_id: 1070
created: 2011/07/21 20:58:48
created_gmt: 2011/07/21 17:58:48
comment_status: open
post_name: agva-goksu-motor-turu
status: publish
post_type: post&lt;/p&gt;

&lt;h1 id=&#34;ağva-göksu-motor-turu&#34;&gt;Ağva-Göksu Motor Turu&lt;/h1&gt;

&lt;p&gt;[vimeo 26728683 600 500]&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://orhanbalci.github.io/post/asansor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://orhanbalci.github.io/post/asansor/</guid>
      <description>

&lt;p&gt;title: Asansör
link: &lt;a href=&#34;http://orhanbalci.net/tr/?p=575&#34;&gt;http://orhanbalci.net/tr/?p=575&lt;/a&gt;
author: Orhan Balci
description:
post_id: 575
created: 2010/01/24 23:18:53
created_gmt: 2010/01/24 20:18:53
comment_status: open
post_name: asansor
status: publish
post_type: post&lt;/p&gt;

&lt;h1 id=&#34;asansör&#34;&gt;Asansör&lt;/h1&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_579&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;470&amp;rdquo; caption=&amp;ldquo;Asansör&amp;rdquo;]&lt;img src=&#34;http://orhanbalci.github.io/wp-content/uploads/asansor.png&#34; alt=&#34;Asansör&#34; /&gt;[/caption]Apartmana girerken adet edindiği üzere telofonun diğer ucundakine &amp;ldquo;Canım apartmana giriyorum yukarı çıkınca seni ararım&amp;rdquo; diyerek telefonu kapattı. Apartmanın iç kısımlarında cep telefonu kapsama alanı dışında kaldığından telefonu kapatırken bu uyarıyı yapmayı alışkanlık edinmişti. Asansörün çağrı düğmesine basıp kat göstergesindeki dijital kırmızı rakamların birer birer azalarak &amp;ldquo;0&amp;rdquo; olmasını bekledi. Aklında bir şeyler atıştırıp karnını doyurduktan sonra yarım kalan romanını okumak vardı. Asansörün kapısını açmasıyla içeriye girmesi bir oldu. İstemsiz şekilde hareket eden parmağı, çıkacağı kat olan &amp;ldquo;3&amp;rdquo; numaralı düğmenin üzerine hafifçe dokundu. Asansör kabinini binadan ayıran raylı panel kapı hafifçe kapandı ve asansör hareket etti. Kabin içindeki demire yaslanır yaslanmaz asansör aniden durdu. Ortalık zifiri karanlığa büründü. Olanlara bir anlam veremiyordu. İlk anda ne olduğunu kavrayamadı. Asansörde kalmış olamazdı, çünkü böyle şeyler hep başkalarının başına gelirdi, onun değil. Yaklaşık 30 saniye sonra durumunu kanıksadı. Asansöre bineli kaç saniye olduğu hakkında hiçbir fikri yoktu. Kaçıncı kattaydı acaba? Asansör kat arasında mı yoksa katta mı kalmıştı? Elektrikler kesilmiş olmalıydı. Aniden bu soruların cevabını bilmesinin kendisine herhangi bir yarar sağlayamayacağının farkına vardı. Birilerini durumundan haberdar etmeliydi. Alfa cep telefonu hizmet sağlayıcısına ait hattının takılı olduğu telefonuna sarıldı düşüncesizce. Evde bekleyen arkadaşına ulaşabilirdi. Fakat cep telefonunun apartmanın bu bölümünde kapsama alnı dışında kaldığı gerçeğiyle tekrar yüzleşmek zorunda kaldı. Şu cep telefonları en lazım olduğu zamanda çekmezdi hep. Zaten alfanında bu konuda pek iyi bir ünü yoktu. Aslında beta hizmet sağlayıcısının sim kartı da vardı onda. Acaba onların kapsama alanı içinde miydi? Pek zannetmiyordu. Zaten diğer telefonunun bataryası da bitmişti. Bir sorununun daha olduğu aklına geldi. Kullandığı telefonun da diğeri gibi pili tükenmek üzereydi. Ya kimseye haber veremezsem diye düşündü. Birden aklına kabinde bulunan acil durum düğmesini kullanmak geldi. Çalışıp çalışmadığını bilmiyordu. Denemekten başka çare yok diye geçirdi aklından. Karanlıkta parmaklarını düğmelerin üzerinde gezdirdi. Telefona benzer bir işaret vardı düğmelerin birinin üzerinde. Düğmeye bastı. Dışarıda ne olduğu konusunda bir bilgisi yoktu. Hatta düğmenin çalışıp çalışmadığından da emin değildi. Birden kabindeki hoparlörden ses duyuldu. Ses kapıcıya aitti. Telefon çalışmış olmalı diye düşündü. Asansörde kaldım diyerek durumunu bildirdi. Kapıcı hangi katta olabileceğini sordu. Galiba 2 ile 3 arasındaydı. Birazdan kabinin alt kısmında bir ışık hüzmesinin içeriye girdiğini gördü. Kapıcının sesi şimdi duyulabiliyordu. Kattaki asansör kapısının acil durum anahtarıyla açılmasıyla birlikte karanlığa alışan gözleri kamaştı. Bu müşkül durumdan kurtulduğu için rahatladı. Yüksekçe bir konumda kalmıştı fakat atlayabilirdi. Ayakları 2. kata değdiğinde mutlu olmuştu. Kapıcı asansörün bakımının yeni yapıldığını, arızanın muhtemelen elektrik şalterinin atmasından kaynaklandığını söyledi. Evine gidip rahatça uyudu. Ertesi gün iş yerinde sabah çayını yudumlarken her sabah yaptığı gibi İnternet&amp;rsquo;ten gazeteleri tarıyordu. Haberi görünce içi ürperdi. Kat arasında kalan asansörden inmek isterken yeniden çalışan asansörde sıkışan şahıs feci şekilde can verdi. Ya ben olsaydım diye düşünüp klavyesinin tuşlarına basmaya devam etti.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://orhanbalci.github.io/post/berber-dukkanindan-diyaloglar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://orhanbalci.github.io/post/berber-dukkanindan-diyaloglar/</guid>
      <description>

&lt;p&gt;title: Berber Dükkânından Diyaloglar
link: &lt;a href=&#34;http://orhanbalci.net/tr/?p=252&#34;&gt;http://orhanbalci.net/tr/?p=252&lt;/a&gt;
author: Orhan Balci
description:
post_id: 252
created: 2009/08/11 20:20:08
created_gmt: 2009/08/11 17:20:08
comment_status: open
post_name: berber-dukkanindan-diyaloglar
status: publish
post_type: post&lt;/p&gt;

&lt;h1 id=&#34;berber-dükkânından-diyaloglar&#34;&gt;Berber Dükkânından Diyaloglar&lt;/h1&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_287&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;470&amp;rdquo; caption=&amp;ldquo;Berber Dükkânından Diyaloglar&amp;rdquo;]&lt;img src=&#34;http://orhanbalci.github.io/wp-content/uploads/berber.png&#34; alt=&#34;Berber Dükkânından Diyaloglar&#34; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;Meseleye giriş yapmadan belirtmek isterim ki bu yazı blogum için bir ilk teşkil ediyor. 2007 yılında yayına başlayan Sekkaşı&amp;rsquo;nın Bayırı&amp;rsquo;nda prensip gereği şimdiye kadar günlük tarzında herhangi bir yazı yayımlamadım. Bu yazıyla başlayarak bu kuralı tarihin tozlu sayfalarına göndermeyi planlıyorum.&lt;/p&gt;

&lt;p&gt;Hafta sonu arkadaşımın düğününe icabet etmek amacıyla Anadolu&amp;rsquo;muzun güzide şehirlerinden birindeydim. İstanbul&amp;rsquo;dan gecenin geç saatlerinde başladığım otobüs yolculuğu ertesi sabahın erken saatlerinde sonlandı. Şehrin adını özellikle zikretmek istemiyorum. Pek saçına sakalına özen gösteren birisi olmadığım için yine sakal tıraşı olmadan yola çıkmıştım. Sonra birden aklıma &amp;ldquo;düğün&amp;rdquo; sebebiyle orada olduğum dolayısıyla da tıraş olmam gerektiği geldi. Şöyle bir çarşı turu attıktan sonra mağazaların, dükkânların büyük çoğunluğunun kepenk kaldırmadığını gördüm. Tamam hafta sonu olabilir, pekâla sabah 9 olabilir ama benim esnaflık anlayışım dükkânı erken açmak olduğundan durumu garipsedim. 15 20 dakikalık bir yürüyüşten sonra nihayet açık bir berber dükkânı bulup daldım içeri. 3 koltuklu klasik bir berber dükkânıydı burası. Koltuklardan birisi doluydu. Hemen ortadaki boş koltuğa kuruldum. Klasik soruya :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- Sakal 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;diyerek cevap verdim.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- Şu saçları da geriye tararsan tam olacak.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sabah rahatsız olduğum konuyu sordum berbere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- Buraların yabancısıyım. Hep böyle geç mi açar esnaf dükkânını buralarda? Sabahtan beri açık berber dükkânı arıyorum.
- Tok esnaf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Öyle ya tok esnaf paraya ihtiyacı yok. Ülkenin hatta dünyanın içinde bulunduğu durumu düşünürsek bazılarına kriz teğet geçiyor hakikaten. Berber sakalımı sabunlarken yan koltuğa bir müşteri oturuyor. Konuşmalardan müşterinin düğün hazırlığı yapan damat adayı olduğunu anlıyorum. Dükkânın yerli müşterisi olduğu da çıkıyor kelimelerden. Bu arada berber ikilisi koyu bir muhabbette dalıyor aralarında:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Berber1 : Abi tatile gidecem ben.
Berber2 : Git git iyi olur. Nereye gidecen?
Berber1 : Marmaris yada Turgutreis. Neresi daha güzel sence ?
Berber2 : Hadi len ordan sen daha şuraya pikniğe gidemezsin ne 
          Marmaris&#39;i  :) ?
Berber1 : Abi ciddiyim neresi güzel sen gitmiştin oralara.
Berber2 : Marmaris güzel. Hem halk plajı var beleş. 
Berber1 : Abi para mühim değil. Hem öyle ben halk malk uğraşamam
          kalabalık olur.
Berber2 : Ulan cebinde harçlık yok bir de halk malk uğraşamam diyosun.
          Gir özel plaja bayıl giriş parası, bayıl şemsiye parası, 
          bayıl şezlong parası göreyim ben seni.
          Hem Turgutreis&#39;de cami yok.
Berber1 : Küçük mescit de mi yok abi.
Berber2 : Yok
Berber1 : Abi girerim otele kılarım namazı ne olacak.
Berber2 : He bi de plajdan otele namaz kılmaya gideceksin.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parasını halktan kazanan esnafımız bile halk olmaktan bıkmış baksanıza halk plajına gitmeye imtina ediyor. Sakal tıraşım bitip saçım tarandıktan sonra borcumu sorup &amp;ldquo;K&amp;rdquo; lirayı berbere ödedim. Günün kalan kısmında damat adayı arkadaşımla buluştuk. Sabah çorba faslından sonra arkadaşı damat tıraşı olmak üzere kuaföre götürdük. Berber değil ha kuaför, yanlış anlaşılmasın. Berberle kuaför arasındaki farkı söylememe gerek yok zaten çalışanlar arasındaki yumuşaklık katsayısı kendini zonk diye belli ediyor. Kuaför salonu her ne kadar daha çekiciymiş gibi görünse de size garanti edebilirim ki berber dükkânı kuaför salonundan daha bakımlıydı. Her neyse arkadaşın damat traşını bitirdikten sonra borcumuzu sorduk tekrar. &amp;ldquo;10K&amp;rdquo; borcu duyunca biraz yadsımadık değil. Tamamdır damat tıraşıdır, fondotenidir, hedesidir, hödösüdür lakin insaftır. Altı üstü bir tıraştır. Ne kadar pazarlık ettiysek de &amp;ldquo;10K&amp;rdquo; lira borcumuzu ödedik. Velhasılı kelam berber dükkânında yan koltukta tıraş olan damat adayımız &amp;ldquo;K&amp;rdquo; liraya tıraş olurken, kuaför salonunda tıraş olan damat adayı arkadaşım &amp;ldquo;10K&amp;rdquo; liraya tıraş oldu. Yani berber abim sen ne kadar benim halk plajında yerim yok desen de halksın hem de dibine kadar. İyi ki öylesin orası ayrı mesele. Kuaför salonundaki arkadaşa da bir tavsiye biraz daha halk olsun. Hem kim bilir halk olmak yarar belki. [ad#Yazi Ici Buyuk]&lt;/p&gt;

&lt;h2 id=&#34;comments&#34;&gt;Comments&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#1636&#34; title=&#34;2009-08-16 17:23:26&#34;&gt;Fatih Ergüven&lt;/a&gt;:&lt;/strong&gt; Arada böyle yazılar da gerekli. Devamını bekliyoruz. (:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#1776&#34; title=&#34;2009-10-24 23:09:31&#34;&gt;salih&lt;/a&gt;:&lt;/strong&gt; Bu tarz yazıları kesinlikle bekliyoruz evet&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#4699&#34; title=&#34;2011-02-15 18:58:19&#34;&gt;engin saraç&lt;/a&gt;:&lt;/strong&gt; güzel yazı arkadaşım teşekkür ederim çok güzel anlatmışsın bende kadıköy suadiyede kuaför salonum var ama halk için (berberde diyebiliriz)istanbula geldinmi beklerim çayımı içmeye :grin: 216 302 40 92&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#42475&#34; title=&#34;2015-03-02 14:18:57&#34;&gt;mustafa&lt;/a&gt;:&lt;/strong&gt; Selamlar, iyi bir sakal tıraşı için ihtiyacın olan bilgiyi www.tirasim.com adresinde bulabilirsin:) Reklamları geçersek, maalesef ufak yerlerde hafta içi sabah 9:00&amp;rsquo;da açık eczane bulamadığımı bilirim. Ayrıca başına gelin ya da damat eklendiğinde fiyatlar maalesef dediğin gibi oluyor. Özellikle gelin saçı söz konusuysa olay çığrından çıkıyor. Düğününe gelin başı değil saçını yaptırıp giden gelin de var, bırak nasılsa damat ödüyor deyip aklınca ne kadar çok ödetirse o kadar kendini değerli (!) hisseden gelin de var.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://orhanbalci.github.io/post/biletofobi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://orhanbalci.github.io/post/biletofobi/</guid>
      <description>

&lt;p&gt;title: Biletofobi
link: &lt;a href=&#34;http://orhanbalci.net/tr/?p=24&#34;&gt;http://orhanbalci.net/tr/?p=24&lt;/a&gt;
author: Orhan Balci
description:
post_id: 24
created: 2008/04/15 19:38:40
created_gmt: 2008/04/15 17:38:40
comment_status: open
post_name: biletofobi
status: publish
post_type: post&lt;/p&gt;

&lt;h1 id=&#34;biletofobi&#34;&gt;Biletofobi&lt;/h1&gt;

&lt;p&gt;Önceleri &amp;ldquo;bilet korkusu&amp;rdquo; diyesim geldi bu hissiyatıma fakat üzerinde biraz düşününce iç dünyama yerleşenin bir korku değil sadece bir endişe olduğuna kanaat getirdim. Aslında herhangi bir endişenin korkuya iltica etmesinin bir eşik değeri olduğu görüşündeyim. Bu eşik değeri ise hissedenin kendi lebileceğine inanırım. Burada amacım endi?e mi korku mu sorusuna yanıt bulmaktan ziyade bu kaygının sebebine dikkat ekmek ve kendime yandaş aramak.  Acaba benden başka bu duyguyu hisseden, yeryüzünde yüreğinin bir köşesinde bunu taşıyan bir insanoğlu var mı? Peki nedir bu &amp;ldquo;bilet endişesi/korkusu/kaygısı&amp;rdquo;? Böyle bir olgunun varlığına kendimi Yalova/Yenikapı 19:30 deniz otobüsü biletime üst üste beşinci kez bakarken yakaladığım anda karar verdim. Evet yanlış okumadınız üst üste tam beş kez. Tekrar, tekrar biletin tarihini, saatini, kalkış yerini, varış yerini, deniz otobüsünde oturacağım koltuğu okuduğumu farkedince bu olayın bende bir saplantı haline geldiği teşhisini koydum kendime. Bunun üstüne &amp;ldquo;ya gişelerde problem olursa&amp;rdquo; düşüncesi de peydah olunca düpe düz paranoyaya dönüştü her şey. Şimdilerde şöyle bir mazinin yamaçlarında gezintiye çıktığımda aynı düşüncelerin otobüs yolculuklarında da beni markaj altına aldığını gülümseyerek anımsıyorum. Otobüs yolculuklarında verilen otuz dakikalık molalar da çoğu zaman &amp;ldquo;ya otobüs beni bırakır da giderse&amp;rdquo; endişesine sahne oluyor. Gülüyorum zira ne kadar komik bir endişe olduğunun tamamen bilincindeyim ama çoğu zaman bilincimizle değil hissiyatımızla hareket ettiğimiz için kendime de hak veriyorum. Öyle ya işin ucuna yanlış otobüse binip niyet Konya iken kendini Hanya&amp;rsquo;da bulmak ihtimali var ne de olsa! Bence psikopatlar pardon psikologlar için yeni bir tez konusu olabilir bu korku. Nitekim güzelim, şirin eklembacaklı örümceklerin bile korkusu oluyor da, o soğuk yazılı biletlerin niye korkusu olmuyor. Biletlerin neyi eksik. Hatta isim bile düşündüm ben bu korkuya &amp;ldquo;biletofobi&amp;rdquo; ya da latince adıyla &amp;ldquo;ticketophobia&amp;rdquo;. Evet psikoloji camiasına hediyem olsun. Telif hakkı falan da istemiyorum. Değil mi bizim de bilim dünyasına bir katkımız olsun. Hiç öyle gülümsemeyin tezime destek olacak malzemelerim var. Geçenlerde izlediğim orjinal adı &amp;ldquo;turistas&amp;rdquo; olan filmde bir turist kafilesinin aracının uçurumdan yuvarlanmasından, organlarının çalınmasına kadar uzanan serüven anlatılmakta. &amp;ldquo;Ne alaka caným&amp;rdquo; dediğinizi duyar gibiyim. Hiç alaka olmaz olur mu? Bir düşünsenize otobüs mola veriyor ve sizi mola yerinde unutuyor. Bunu fırsat bilen iç organ mafyası sizi kendine hedef seçiyor. Hatta ve hatta otobüs şöförü ve muavini de bu mafyaya yardım ve yataklık için sizi unutmuş numarası yapıyorlar. Aslında onlar da mafyanın elemanı. Tırstınız değil mi? Bakın bakın tüylerim diken diken oldu.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://orhanbalci.github.io/post/birlestirmeli-siralama-merge-sort-algoritma-appleti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://orhanbalci.github.io/post/birlestirmeli-siralama-merge-sort-algoritma-appleti/</guid>
      <description>

&lt;p&gt;title: Birleştirmeli Sıralama (Merge Sort) Algoritma Appleti
link: &lt;a href=&#34;http://orhanbalci.net/tr/?p=503&#34;&gt;http://orhanbalci.net/tr/?p=503&lt;/a&gt;
author: Orhan Balci
description:
post_id: 503
created: 2009/12/13 18:57:06
created_gmt: 2009/12/13 15:57:06
comment_status: open
post_name: birlestirmeli-siralama-merge-sort-algoritma-appleti
status: publish
post_type: post&lt;/p&gt;

&lt;h1 id=&#34;birleştirmeli-sıralama-merge-sort-algoritma-appleti&#34;&gt;Birleştirmeli Sıralama (Merge Sort) Algoritma Appleti&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Algoritma Adı:&lt;/strong&gt; Birleştirmeli Sıralama Algoritması (Merge Sort) &lt;strong&gt;Algoritma Türü:&lt;/strong&gt; Sıralama Algoritması &lt;strong&gt;Açıklama:&lt;/strong&gt; Parçala yönet mantığıyla geliştirilmiş özyinelemeli (recursive) sıralama algoritmasıdır. Temel olarak üç aşamadan oluşur. Algoritma kendine verilen diziye ikiye böler. Birinci ve ikinci parçaların sıralanmasını sağlar. Son olarak da sıralı iki altdiziyi birleştirir. Örnek olarak 6 elemanlı 6 5 4 3 2 1 dizisini sıralayalım.  1. Adım : Dizi 6 5 4 ve 3 2 1 olmak üzere ikik alt diziye ayrılır. 2. Adım : 6 5 4 alt dizisi 6 ve 5 4 olmak üzere ikiye ayrılır. 3. Adım : 6 tek elemanlı olduğu için sıralanmış kabul edilir. 4. Adım : 5 4 dizisi 5 ve 4 olmak üzere ikiye ayrılır. 5. Adım : 5 ve 4 tek elemanlı olduklarından sıralanmış kabul edilir. 6. Adım : 5 ve 4 birleştirilir. Sıralama 4 5 şeklinde olur. 7. Adım : 6 ve 4 5 dizisi birleştirilir. Sıralama 4 5 6 şeklinde olur. İlk dizimizin ilk alt dizisi sıralanmış olur. 2 8. Adım : 3 2 1 dizisi 3 ve 2 1 olarak ikiye ayrılır. 9. Adım : 3 tek elemanlı olduğundan sıralı kabul edilir. 10. Adım : 2 1 dizisi 2 ve 1 olmak üzere ikiye ayrılır. 11. Adım : 2 ve 1 tek elemanlı olduklarından sıralanmış kabul edilir. 12. Adım : 2 ve 1 birleştirilir. Sıralama 1 2 olur. 13. Adım : 3 ve 2 1 dizileri birleştirilir. Sıralama 1 2 3 şeklinde olur. İlk dizimizin ikinci alt dizisi de sıralanmış olur. 14. Adım : 4 5 6 ve 1 2 3 alt dizileri birleştirilerek 1 2 3 4 5 6 sıralı dizisi oluşur. Algoritma sonlanır.&lt;/p&gt;

&lt;p&gt;Algoritma Java Kodu : [java] int[] mergeSort(int[] siralanacakArray) { //eğer sıralanacak dizi uzunluğu 2&amp;rsquo;den küçükse //dizi sıralı sayılır if (siralanacakArray.length &amp;lt; 2) { return siralanacakArray; } //ikiye bölünen dizi boyutlarını hesaplıyoruz int ilkArrayBoyutu = siralanacakArray.length / 2; int ikinciArrayBoyutu = siralanacakArray.length - ilkArrayBoyutu; //iki alt diziyi ilklendiriyoruz int[] ilkArray = new int[ilkArrayBoyutu]; int[] ikinciArray = new int[ikinciArrayBoyutu]; //dizinin ilk parçasını bölüyoruz for (int i = 0; i &amp;lt; ilkArrayBoyutu; i++) { ilkArray[i] = siralanacakArray[i]; } //Dizinin geri kalanını ikinci diziye atıyoruz int j = 0; for (int k = ilkArrayBoyutu; k &amp;lt; siralanacakArray.length &amp;amp;&amp;amp; j &amp;lt; ikinciArrayBoyutu; k++, j++) { ikinciArray[j] = siralanacakArray[k]; } //Böldüğümüz ilk diziyi sıralıyoruz int[] siraliIlkArray = mergeSort(ilkArray); //Böldüğümüz ikinci diziyi sıralıyoruz int[] siraliIkinciArray = mergeSort(ikinciArray); int m = 0, n = 0, y = 0; //Sıralı iki diziyi tekrar birleştiriyoruz. //Sırasıyla bütün elemanları karşılaştırarak küçük olanı önce //olmak kaydıyla ilk dizide birleştiriyoruz while (m &amp;lt; ilkArrayBoyutu &amp;amp;&amp;amp; n &amp;lt; ikinciArrayBoyutu) { if (siraliIlkArray[m] &amp;lt;= siraliIkinciArray[n]) { siralanacakArray[y] = siraliIlkArray[m]; m++; y++; } else if (siraliIlkArray[m] &amp;gt; siraliIkinciArray[n]) { siralanacakArray[y] = siraliIkinciArray[n]; n++; y++; } } //Eğer ilk dizide eleman kalmışsa bunları listenin sonuna ekliyoruz while (m &amp;lt; ilkArrayBoyutu) { siralanacakArray[y] = siraliIlkArray[m]; y++; m++; } //Eğer ikinci dizide eleman kalmışsa bunları listenin sonuna ekliyoruz while (n &amp;lt; ikinciArrayBoyutu) { siralanacakArray[y] = siraliIkinciArray[n]; y++; n++; } //Sıralanmış diziyi dışarı veriyoruz. return siralanacakArray; } [/java] Javascript implementasyonu memory kullanimi daha iyi olan bir cozum : [javascript] fs = require(&amp;lsquo;fs&amp;rsquo;) fs.readFile(&amp;lsquo;./merge_sort.txt&amp;rsquo;, &amp;lsquo;utf8&amp;rsquo;, function (err, unsorted_array_data) { if (err) { return console.log(err); } var array_data = unsorted_array_data.split(&amp;rdquo;\r\n&amp;rdquo;); var input= array_data[1].split(&amp;rdquo; &amp;ldquo;).map(function (item) { return parseInt(item); }) merge_sort(input, 0, input.length); console.log(input.join(&amp;rdquo; &amp;ldquo;)); }); function merge(unsorted_array, begin_index, middle_point, end_index) { var i = begin_index; var j = middle_point; var merge_result = new Array(end_index-begin_index); var result_counter = 0; while (i &amp;lt; middle_point &amp;amp;&amp;amp; j &amp;lt; end_index) { if(unsorted_array[i] &amp;lt;= unsorted_array[j]){ merge_result[result_counter] = unsorted_array[i]; i++; result_counter++; }else if(unsorted_array[j] &amp;lt; unsorted_array[i]){ merge_result[result_counter] = unsorted_array[j]; j++; result_counter++; } } while(i &amp;lt; middle_point){ merge_result[result_counter] = unsorted_array[i]; i++; result_counter++; } while(j &amp;lt; end_index){ merge_result[result_counter] = unsorted_array[j]; j++; result_counter++; } for (var k = begin_index; k &amp;lt; end_index; k++) { unsorted_array[k] = merge_result[k-begin_index]; } } var merge_sort = function (unsorted_array, begin_index, end_index) { if(end_index - begin_index == 1){ return; } var middle_point = Math.floor((begin_index + end_index) / 2); arguments.callee(unsorted_array, begin_index, middle_point); arguments.callee(unsorted_array, middle_point, end_index); merge(unsorted_array, begin_index, middle_point, end_index); } [/javascript]&lt;/p&gt;

&lt;h2 id=&#34;comments&#34;&gt;Comments&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#2743&#34; title=&#34;2010-05-25 22:31:56&#34;&gt;admin&lt;/a&gt;:&lt;/strong&gt; O dizi tersten sıralı. Burada kastettiğim sıralama artan bir sıralamadır. Verilen algoritma herhangi bir diziyi sıralamakta kullanılır. Yani senin verdiğin dizi de aynı algoritma kullanarak sıralanabilir.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#2740&#34; title=&#34;2010-05-25 19:35:01&#34;&gt;komagine&lt;/a&gt;:&lt;/strong&gt; iyide o dizi zaten sıralı karambol bi diziyi nasıl sıralıyo meselam 34 56 4 10 77 51 93 30 52 ?????? bi anlatırsan sevinirim :roll:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#7337&#34; title=&#34;2012-12-20 20:35:19&#34;&gt;emre&lt;/a&gt;:&lt;/strong&gt; admin rica etsem yukarıdakı gifi indirebilme şansımız varmı bitirme sunum ıcın lazım da???&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#7343&#34; title=&#34;2012-12-21 10:35:42&#34;&gt;admin&lt;/a&gt;:&lt;/strong&gt; hacı abi o gif değil applet :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://orhanbalci.github.io/post/breadth-first-search-yuzey-ocelikli-arama/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://orhanbalci.github.io/post/breadth-first-search-yuzey-ocelikli-arama/</guid>
      <description>

&lt;p&gt;title: Breadth First Search (Yuzey Ocelikli Arama)
link: &lt;a href=&#34;http://orhanbalci.net/tr/?p=1380&#34;&gt;http://orhanbalci.net/tr/?p=1380&lt;/a&gt;
author: Orhan Balci
description:
post_id: 1380
created: 2015/04/19 05:43:26
created_gmt: 2015/04/19 02:43:26
comment_status: open
post_name: breadth-first-search-yuzey-ocelikli-arama
status: publish
post_type: post&lt;/p&gt;

&lt;h1 id=&#34;breadth-first-search-yuzey-ocelikli-arama&#34;&gt;Breadth First Search (Yuzey Ocelikli Arama)&lt;/h1&gt;

&lt;p&gt;Javascript implementasyonu : [javascript] var adjecencyList = []; var nodes = []; fs = require(&amp;lsquo;fs&amp;rsquo;) fs.readFile(&amp;lsquo;C:/Users/admin/WebstormProjects/untitled/breadth_first_search.txt&amp;rsquo;, &amp;lsquo;utf8&amp;rsquo;, function (err, graph_data) { if (err) { return console.log(err); } var edges = graph_data.split(&amp;rdquo;\r\n&amp;rdquo;); breadth_first_search(edges); }); function buildAdjecencyList(edges) { edges.every(function (edge, index) { if (index === 0) { //node count edge count adjecencyList = new Array(edge.split(&amp;rdquo; &amp;ldquo;).map(function (item) { return parseInt(item); })[0]) return true; } vertices = edge.split(&amp;rdquo; &amp;ldquo;).map(function (item) { return parseInt(item); }); if (nodes[vertices[0]] === undefined) nodes[vertices[0]] = {vertex: vertices[0], shortestDistance: Number.MAX_VALUE}; if (nodes[vertices[1]] === undefined) nodes[vertices[1]] = {vertex: vertices[1], shortestDistance: Number.MAX_VALUE}; if (adjecencyList[vertices[0]] === undefined) adjecencyList[vertices[0]] = []; adjecencyList[vertices[0]].push(nodes[vertices[1]]); return true; }) } var breadth_first_search = function (edges) { var result = &amp;ldquo;&amp;rdquo;; buildAdjecencyList(edges); var processQueue = []; nodes[1].shortestDistance = 0; processQueue.push(nodes[1]); while (processQueue.length &amp;gt; 0) { var node = processQueue.shift(); if (node.shortestDistance &amp;lt; Number.MAX_VALUE) { if (adjecencyList[node.vertex] === undefined) { continue; } for (var i = 0; i &amp;lt; adjecencyList[node.vertex].length; i++) { adjecentNode = adjecencyList[node.vertex][i]; if (adjecentNode.shortestDistance === Number.MAX_VALUE) { processQueue.push(adjecentNode); adjecentNode.shortestDistance = node.shortestDistance + 1; } } } } nodes.every(function (node) { if (node.shortestDistance === Number.MAX_VALUE) { result = result.concat(-1).concat(&amp;rdquo; &amp;ldquo;); } else { result = result.concat(node.shortestDistance).concat(&amp;rdquo; &amp;ldquo;); } return true; }) console.log(result); } [/javascript] [ad#Yazi Ici Buyuk]&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://orhanbalci.github.io/post/bubble-sort-kabarcik-siralama-algoritma-appleti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://orhanbalci.github.io/post/bubble-sort-kabarcik-siralama-algoritma-appleti/</guid>
      <description>

&lt;p&gt;title: Kabarcık Sıralama (Bubble Sort ) Algoritma Appleti
link: &lt;a href=&#34;http://orhanbalci.net/tr/?p=11&#34;&gt;http://orhanbalci.net/tr/?p=11&lt;/a&gt;
author: Orhan Balci
description:
post_id: 11
created: 2007/06/20 23:57:48
created_gmt: 2007/06/20 21:57:48
comment_status: open
post_name: bubble-sort-kabarcik-siralama-algoritma-appleti
status: publish
post_type: post&lt;/p&gt;

&lt;h1 id=&#34;kabarcık-sıralama-bubble-sort-algoritma-appleti&#34;&gt;Kabarcık Sıralama (Bubble Sort ) Algoritma Appleti&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Algoritma Adı:&lt;/strong&gt; Kabarcık Sıralama Algoritması (Bubble Sort) &lt;strong&gt;Algoritma Türü:&lt;/strong&gt; Sıralama Algoritması &lt;strong&gt;Açıklama:&lt;/strong&gt; Sıralanacak eleman kümesinden ilk eleman alınır. Eğer kendinden sonrakinden büyükse yerleri değiştirilir. Sonraki elemana geçilir ve aynı işlem tekrarlanır. Dizinin sonuna varıldığında en büyük eleman sonda yer alır. Dizinin başına dönerek bu işlem sondan birinci elemana kadar tekrarlanır. Her adımda bir eleman daha azaltılarak devam eden iterasyon bütün elemanların yerini bulmasıyla sonlanır. Algoritmanın javada implement edilmiş hali : [java] for (int i = 1; i &amp;lt; sortArray.length; i++) { for (int j = 0; j &amp;lt; sortArray.length - i; j++) { if(sortArray[j] &amp;gt; sortArray[j+1]) { temp = sortArray[j+1]; sortArray[j+1] = sortArray[j]; sortArray[j] = temp; } } } [/java] Algoritmanin JavaScript implementasyonu : [javascript] /** * Created by Orhan Balci on 10.04.2015. */ var bubleSort = function(arrayToBeSorted){ for(var i = 1; i &amp;lt; arrayToBeSorted.length; i++){ for (var j = 0; j &amp;lt; arrayToBeSorted.length-1; j++) { if(arrayToBeSorted[j+1] &amp;lt; arrayToBeSorted[j]){ var tempSwap = arrayToBeSorted[j]; arrayToBeSorted[j] = arrayToBeSorted[j+1]; arrayToBeSorted[j+1] = tempSwap; } } } } var printNumbers = function(arrayTobePrinted){ var logMessage = &amp;ldquo;&amp;rdquo;; for (var i = 0; i &amp;lt; arrayTobePrinted.length; i++) { logMessage += arrayTobePrinted[i] + &amp;ldquo; &amp;ldquo;; } console.log(logMessage); } var testSorting = function() { var numberArray = []; numberArray.length = 100; for (var i = 0; i &amp;lt; numberArray.length; i++) { numberArray[i] = Math.round(Math.random() * 100); } printNumbers(numberArray); bubleSort(numberArray); printNumbers(numberArray); } testSorting(); [/javascript]&lt;/p&gt;

&lt;p&gt;[ad#Yazi Ici]&lt;/p&gt;

&lt;h2 id=&#34;comments&#34;&gt;Comments&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#29&#34; title=&#34;2007-06-29 20:26:13&#34;&gt;Osman N. Yogurtcu&lt;/a&gt;:&lt;/strong&gt; Orhan, bu applet çalışmıyor. Sebep? :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#30&#34; title=&#34;2007-06-30 13:54:56&#34;&gt;Orhan&lt;/a&gt;:&lt;/strong&gt; Niye çalışmasın güzel kardeşim :). Browserinda Java plugini varsa çalışır. Belki birde JRE&amp;rsquo;ni update etmen gerekebilir&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#242&#34; title=&#34;2008-02-29 13:50:34&#34;&gt;hazan_06&lt;/a&gt;:&lt;/strong&gt; Sıralama uygulaman güzel olmuş. Benim de bir projem var ama nasıl yapacağımı bilmiyorum sıralama algoritmasından.Ben 10 tane resmi büyükten küçüğe doğru sıralayacağım sıralama algoritmasıyla. Bana yardımcı olursanız nasıl yapacağım konusunda teşekkür ederim. Mailinizi bekleyeceğim.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#1434&#34; title=&#34;2009-05-24 13:09:13&#34;&gt;mdesigner&lt;/a&gt;:&lt;/strong&gt; paylşım için teş.ler benim final ödevim bu dersten mesela 5,7,28,64,2,3,67 bu sayıları bu yöntemle yazmam lazımmış yardımcı olursan sevinirim&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#1446&#34; title=&#34;2009-06-02 10:12:52&#34;&gt;mavzeroglu&lt;/a&gt;:&lt;/strong&gt; benim bir final ödevim var yardimci olabilirseniz sevinirim c++ da bubble sort yöntemiyle sayilarin siralanmasi icin bir program yazmamiz gerekiyo ama ben bilmiyorum bu konuda bana yardimci olabilirseniz sevinirim programda su özellikler isteniyo programın basinda kisiden kac sayi girilecegi istenecek ve teker teker sayilar istenecek ardindan büyükten küçüge mi yoksa kücükten büyügemi siralanacagi sorulacak siralama bittikten sonra ise cikmak istiyorsan h ye devam etmek istiyorsan e ye bas diye soracak ve e ye basinca program tekrar basa alip bizden aynı seyleri tekrar yapmamizi isteecek yani program tek seferlik olmayacak bo konuda yardim edebilirseniz cok sevinirim cünkü bu benim final ödevim yardiminiz icin simdiden tesekkür ederim&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#1443&#34; title=&#34;2009-06-01 12:40:22&#34;&gt;mahmut&lt;/a&gt;:&lt;/strong&gt; arkadaşlar bu sitenin neresinde yazılmış halini bulabilirim ?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#5448&#34; title=&#34;2012-05-08 13:45:19&#34;&gt;admin&lt;/a&gt;:&lt;/strong&gt; Ödevlere yardımcı olmuyorum :). Sadece takıldığın yer varsa orayı cevaplayabilirim&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#5449&#34; title=&#34;2012-05-08 14:53:38&#34;&gt;isimsiz kahraman&lt;/a&gt;:&lt;/strong&gt; Kırnap mısın?Aksöz mü?(Ahmet) :smile:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#5444&#34; title=&#34;2012-05-06 00:36:50&#34;&gt;ahmet&lt;/a&gt;:&lt;/strong&gt; Yüksekliği h ve 1’den 2h+1-1 , e kadar anahtarı olan mükemmel bir şekilde dengelenmiş ikili ağacı üretmek için bir fonksiyon yazınız. hocam ödev var yardımcı olur musunuz?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://orhanbalci.github.io/post/carpisma-algilama-yontemleri-ve-algoritmalari-1-matematik-temelleri/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://orhanbalci.github.io/post/carpisma-algilama-yontemleri-ve-algoritmalari-1-matematik-temelleri/</guid>
      <description>

&lt;p&gt;title: Çarpışma Algılama Yöntemleri ve Algoritmaları #1: Matematik Temelleri
link: &lt;a href=&#34;http://orhanbalci.net/tr/?p=874&#34;&gt;http://orhanbalci.net/tr/?p=874&lt;/a&gt;
author: Orhan Balci
description:
post_id: 874
created: 2010/10/29 12:36:24
created_gmt: 2010/10/29 09:36:24
comment_status: open
post_name: carpisma-algilama-yontemleri-ve-algoritmalari-1-matematik-temelleri
status: publish
post_type: post&lt;/p&gt;

&lt;h1 id=&#34;çarpışma-algılama-yöntemleri-ve-algoritmaları-1-matematik-temelleri&#34;&gt;Çarpışma Algılama Yöntemleri ve Algoritmaları #1: Matematik Temelleri&lt;/h1&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_878&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;600&amp;rdquo; caption=&amp;ldquo;Çarpışma Algılama Algoritmaları&amp;rdquo;]&lt;img src=&#34;http://orhanbalci.github.io/wp-content/uploads/collision_detection_banner.png&#34; alt=&#34;&#34; /&gt;[/caption] Yeni bir makale dizisiyle tecrübelerimi sizinle paylaşmak istiyorum. Yine uzun soluklu bir yazı dizisi olacağını tahmin ediyorum. Çarpışma algılama yöntemleri fiziksel olayların taklit edildiği veya birebir simüle edildiği yazılımlarda nesneler arasındaki etkileşimi gerçekçi kılmak için kullanılırlar. Oyunlar ve simülasyonlar temel kullanım alanları olmakla beraber haptik uygulamaları, sanal gerçeklik uygulamaları da akademik alanda çarpışma kontrol algoritmalarının ilgi alanındadır. İçerisinde çok fazla geometrik problem barındıran bu alanda geliştirilen algoritmalar tatminkar sonuçlar üretebilmektedir. Özellikle oyun sektörünün çok fazla gelişmesiyle bu konu üzerinde ilerleme de gayet hızlı olmuştur. Bu kadar girizgahtan sonra çarpışma algılama algoritmaları geliştirirken göz önünde bulundurulan kriterlere değinelim :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ölçeklenebilirlik : Üzerlerinde çarpışma kontrolü yapılacak olan nesne sayısının azaltılıp arttıralabilmesi durumudur. Az sayıda nesne üzerinde iyi sonuçlar verebilen bir algoritmanın çok fazla sayıda nesne üzerinde işe yarayacağının garantisi yoktur. Örneğin elinizle sanal ortamdaki kısıtlı sayıda nesnelerle etkileşime girmenizi sağlayan bir sanal gerçeklik uygulaması için gerekli olan algoritma ile yüzlerce aracın içerisinde bulunduğu trafiği simüle etmek için gerekli olan algoritma ölçeklenebilirlik açısından farklı olabilir.&lt;/li&gt;
&lt;li&gt;Performans : Bir önceki kriterle doğrudan ilintili olan bir problemdir. Geliştirdiğiniz çözüm yöntemi belki binlerce nesne üzerinde çalışabilir fakat bunu saniyeler mertebesinde yapıyorsa çoğu zaman kullanışsızdır. Çarpışma algılama algoritmalarının kullanıldığı uygulamaların büyük çoğunluğu gerçek zamanlıdır. Yani hesaplamalrı en kötü ihtimalle 60 hetz&amp;rsquo;de yapılabiliyor olması gereklidir. Bu da sistemdeki tüm işlemler için elinizde yaklaşık olarak 1000ms/60 = 16.67 mili saniye var demektir. Bir işlemci için bu zaman uzun olmakla beraber çözdüğünüz problem yüzlerce hatta binlerce nesneyi içeriyorsa ciddi bir problemle karşı karşıyasınız demektir.&lt;/li&gt;
&lt;li&gt;Güvenilirlik : Bu tür algoritmalar doğası gereği çok fazla sayıda ondalık sayı işlemi gerektirir. Bu da her zaman için hataya açık bir konu olmuştur. Geometrik nesnelerin tanımlanmasından kaynaklanan hatalarda sistemi kararsız hala getirebilir. Bu tür sorunlar gözönünde bulundurulduğunda çok çeşitli çarpışma sorgu girdisine karşı algoritmanın her zaman aynı güvenilirlikte sonuç vermesi azami önem taşımaktadır.&lt;/li&gt;
&lt;li&gt;Hassasiyet : Yine yukarıdaki kriteri tamamlar niteliktedir. Uygulamanın türüne göre hassasiyet belirlemek mümkündür. Örneğin cerrahi bir simülatör için mm hassasiyet bile yeterli olmayabilecekken basit bir oyunda 10-15 cm hassasiyet sorun olmayacaktır.
En temelde geometrik sorulara cevap aradığımız için temel lineer cebir bilgisi şarttır. Çok sayıda matris ve vektör işlemi yapacağımızdan bu işlemleri destekleyen kütüphanelerden yararlanmak işinizi büyük oranda kolaylaştıracaktır. Java tarafında bunun için Cern araştırmaları kapsamında geliştirilen &lt;a href=&#34;http://acs.lbl.gov/software/colt/&#34;&gt;Colt&lt;/a&gt; kütüphanesini önerebilirim (yazacağım örneklerde bu kütüphaneyi kullanacağım). Bu kütüphaneyi kullanarak matris işlemleri yapmayı bir örnekle görelim. [java] void doSampleOperations() { DoubleFactory2D f1 = DoubleFactory2D.dense; DoubleMatrix2D m2d = f1.random(3, 3); System.out.println(&amp;ldquo;Rastgele matrix:&amp;ldquo;); System.out.println(m2d.toString()); Algebra a = new Algebra(); DoubleMatrix2D m2d2 = a.transpose(m2d); System.out.println(&amp;ldquo;Transpose alınmış hali:&amp;ldquo;); System.out.println(m2d2); DoubleMatrix2D m2dInverse = a.inverse(m2d); System.out.println(&amp;ldquo;Tersi:&amp;ldquo;); System.out.println(m2dInverse); System.out.println(a.det(m2d)); System.out.println(a.det(m2d2)); } [/java] [ad#Yazi Ici]&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;comments&#34;&gt;Comments&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#4349&#34; title=&#34;2010-11-18 04:44:49&#34;&gt;vantutiri&lt;/a&gt;:&lt;/strong&gt; Harika bi yazı.Bu yazının devamını bekleyemiyorum&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;#4209&#34; title=&#34;2010-10-30 01:37:41&#34;&gt;KayL&lt;/a&gt;:&lt;/strong&gt; Yazı için teşekkürler.Sabırsızlıkla bekliyoruz&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://orhanbalci.github.io/post/dependency-injection-guice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://orhanbalci.github.io/post/dependency-injection-guice/</guid>
      <description>

&lt;p&gt;title: Dependency Injection : Guice
link: &lt;a href=&#34;http://orhanbalci.net/tr/?p=1326&#34;&gt;http://orhanbalci.net/tr/?p=1326&lt;/a&gt;
author: Orhan Balci
description:
post_id: 1326
created: 2014/11/21 21:22:46
created_gmt: 2014/11/21 18:22:46
comment_status: open
post_name: dependency-injection-guice
status: publish
post_type: post&lt;/p&gt;

&lt;h1 id=&#34;dependency-injection-guice&#34;&gt;Dependency Injection : Guice&lt;/h1&gt;

&lt;p&gt;Dependency Injection test edilebilir, esnek, ve kontrol edilebilir kod geliştirmek için kullanılan bir tasarım kalıbıdır. Geliştirdiğiniz sınıfların bağımlılıklarının,kullanması gereken servislerin bir arayüz vasıtasıyla dışarıdan verilmesine olanak tanır. Bu makalede google tarafından geliştirilen Guice Dependency Injection kütüphanesi ile bir örnek göstereceğim. Örneğimiz yapay sinir ağlarında kullanılan nöronlar ve bunların bağımlı olduğu aktivasyon fonksiyonlarının implementasyonu şeklinde olacak. Öncelikle bağımlı olunan aktivasyon fonksiyonu için bir arayüz tanımlayalım : [java] public interface ActivationFunction { public abstract double apply(double inp); public abstract double reverse(double output); } [/java] Bu arayüzü gerçekleyen iki tane aktivasyon fonksiyon sınıfı yazalım : [java] public class ReluFunction implements ActivationFunction { @Override public double apply(double inp) { return Math.log(1 + Math.exp(inp)); } @Override public double reverse(double input) { return 1d / (1 + Math.exp(-input)); } } [/java] [java] public class IdentityFunction implements ActivationFunction { @Override public double apply(double inp) { return inp; } @Override public double reverse(double output) { return output; } } [/java] Şimdi de bu aktivasyon fonksiyonlarını kullanacak olan yapay sinir ağının nöron sınıfını geliştirelim. Bu sınıfı temel injection yöntemi olan constructor (yapıcı method) üzerinden inject edelim. &lt;strong&gt;ActivationFunction&lt;/strong&gt; bağımlılğını constructor parametresi olarak geçmeliyiz ve bu constructoru &lt;strong&gt;@inject&lt;/strong&gt; annotasyonu ile işaretleyelim. Dikkat etmemiz gereken noktalar constructor parametresi ve @inject annotasyonu. [java] import com.google.inject.Inject; public class Neuron { private ActivationFunction af; @Inject public Neuron(ActivationFunction pAf){ af = pAf; } public double getResult(double inp){ return af.apply(inp); } }[/java] Sonraki adımımız Guice&amp;rsquo;e Neuron nesneleri oluştururken kullanması gereken ActivationFunction implementasyon tipini bildirmek. İleride dependency değişimi yapmak gerekirse tek yapmamız gereken bu sınıfı değiştirmek olacaktır. &lt;strong&gt;Module&lt;/strong&gt; arayüzünü gerçekleyen bir sınıf yazıyoruz. Burada Guice&amp;rsquo;e ActivationFunction bağımlılığı için IdentityFunction implementasyonunu kullanmasını söylüyoruz. [java] import com.google.inject.Binder; import com.google.inject.Module; public class NeuralNetworkModule implements Module { @Override public void configure(Binder binder) { binder.bind(ActivationFunction.class).to(IdentityFunction.class); } } [/java] Yeni bir Neuron nesnesi oluşturmak istediğimizde &lt;strong&gt;Injector&lt;/strong&gt; sınıfının &lt;strong&gt;getInstance&lt;/strong&gt; methodunu kullanıyoruz. Dependency Injection kullanırken new ile herhangi bir nesne oluşturmuyoruz. [java] import com.google.inject.Guice; import com.google.inject.Injector; public class Main { public static void main(String[] args) { Injector inj = Guice.createInjector(new NeuralNetworkModule()); Neuron n = inj.getInstance(Neuron.class); System.out.println(n.getResult(5)); } } [/java] [ad#Yazi Ici Buyuk]&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>